<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Anki iOS - Made by ©️Muhammad Daler</title>
    <script>
        // Tailwind CSS - Lightweight version
        if (!window.tailwind) {
            const style = document.createElement('style');
            style.textContent = `
                .hidden { display: none !important; }
                .flex { display: flex; }
                .grid { display: grid; }
                .block { display: block; }
                .inline-block { display: inline-block; }
                .flex-col { flex-direction: column; }
                .flex-row { flex-direction: row; }
                .items-center { align-items: center; }
                .justify-center { justify-content: center; }
                .justify-between { justify-content: space-between; }
                .justify-around { justify-content: space-around; }
                .flex-1 { flex: 1; }
                .flex-wrap { flex-wrap: wrap; }
                .grid-cols-2 { grid-template-columns: repeat(2, 1fr); }
                .gap-2 { gap: 0.5rem; }
                .gap-3 { gap: 0.75rem; }
                .gap-4 { gap: 1rem; }
                .gap-6 { gap: 1.5rem; }
                .w-full { width: 100%; }
                .h-full { height: 100%; }
                .h-screen { height: 100vh; }
                .p-2 { padding: 0.5rem; }
                .p-3 { padding: 0.75rem; }
                .p-4 { padding: 1rem; }
                .p-6 { padding: 1.5rem; }
                .px-2 { padding-left: 0.5rem; padding-right: 0.5rem; }
                .px-4 { padding-left: 1rem; padding-right: 1rem; }
                .py-2 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
                .py-3 { padding-top: 0.75rem; padding-bottom: 0.75rem; }
                .py-4 { padding-top: 1rem; padding-bottom: 1rem; }
                .m-2 { margin: 0.5rem; }
                .m-4 { margin: 1rem; }
                .mt-2 { margin-top: 0.5rem; }
                .mt-4 { margin-top: 1rem; }
                .mt-6 { margin-top: 1.5rem; }
                .mb-2 { margin-bottom: 0.5rem; }
                .mb-4 { margin-bottom: 1rem; }
                .mb-6 { margin-bottom: 1.5rem; }
                .ml-2 { margin-left: 0.5rem; }
                .mr-2 { margin-right: 0.5rem; }
                .mx-2 { margin-left: 0.5rem; margin-right: 0.5rem; }
                .mx-4 { margin-left: 1rem; margin-right: 1rem; }
                .text-center { text-align: center; }
                .text-left { text-align: left; }
                .text-right { text-align: right; }
                .text-xs { font-size: 0.75rem; }
                .text-sm { font-size: 0.875rem; }
                .text-base { font-size: 1rem; }
                .text-lg { font-size: 1.125rem; }
                .text-xl { font-size: 1.25rem; }
                .text-2xl { font-size: 1.5rem; }
                .text-3xl { font-size: 1.875rem; }
                .font-bold { font-weight: 700; }
                .font-semibold { font-weight: 600; }
                .font-medium { font-weight: 500; }
                .font-normal { font-weight: 400; }
                .font-mono { font-family: monospace; }
                .rounded { border-radius: 0.25rem; }
                .rounded-lg { border-radius: 0.5rem; }
                .rounded-xl { border-radius: 0.75rem; }
                .rounded-full { border-radius: 9999px; }
                .border { border-width: 1px; }
                .border-t { border-top-width: 1px; }
                .border-b { border-bottom-width: 1px; }
                .bg-gray-800 { background-color: #1f2937; }
                .bg-gray-900 { background-color: #111827; }
                .bg-blue-600 { background-color: #2563eb; }
                .bg-red-600 { background-color: #dc2626; }
                .bg-green-600 { background-color: #16a34a; }
                .bg-yellow-600 { background-color: #ca8a04; }
                .bg-purple-600 { background-color: #9333ea; }
                .text-white { color: white; }
                .text-gray-400 { color: #9ca3af; }
                .text-gray-500 { color: #6b7280; }
                .text-blue-400 { color: #60a5fa; }
                .text-red-400 { color: #f87171; }
                .text-green-400 { color: #4ade80; }
                .text-yellow-400 { color: #fbbf24; }
                .text-purple-400 { color: #c084fc; }
                .opacity-50 { opacity: 0.5; }
                .opacity-80 { opacity: 0.8; }
                .truncate { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
                .divide-y > * + * { border-top-width: 1px; }
                .shadow { box-shadow: 0 1px 3px 0 rgba(0,0,0,0.1); }
                .shadow-lg { box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1); }
                .transition { transition: all 0.2s; }
                .scale-95 { transform: scale(0.95); }
                .uppercase { text-transform: uppercase; }
            `;
            document.head.appendChild(style);
        }
    </script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    
    <style>
        /* Anki macOS Style */
        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f5f5f7;
            --bg-tertiary: #e8e8ed;
            --text-primary: #000000;
            --text-secondary: #6d6d72;
            --accent: #007aff;
            --accent-hover: #0056cc;
            --danger: #ff3b30;
            --success: #34c759;
            --warning: #ff9500;
            --card-bg: #ffffff;
            --border-color: #c7c7cc;
            --shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            --radius: 12px;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg-primary: #000000;
                --bg-secondary: #1c1c1e;
                --bg-tertiary: #2c2c2e;
                --text-primary: #ffffff;
                --text-secondary: #8e8e93;
                --accent: #0a84ff;
                --accent-hover: #409cff;
                --danger: #ff453a;
                --success: #32d74b;
                --warning: #ff9f0a;
                --card-bg: #2c2c2e;
                --border-color: #38383a;
                --shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
            font-size: 16px;
            line-height: 1.5;
        }

        /* Container */
        .container {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        .header {
            height: 60px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            position: sticky;
            top: 0;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        /* Navigation */
        .nav {
            display: flex;
            gap: 2px;
            background: var(--bg-tertiary);
            padding: 4px;
            border-radius: 9px;
            margin: 0 20px;
        }

        .nav-item {
            padding: 8px 16px;
            border-radius: 7px;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .nav-item.active {
            background: var(--bg-primary);
            color: var(--text-primary);
            box-shadow: var(--shadow);
        }

        /* Main Content */
        .main-content {
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        /* Views */
        .view {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow-y: auto;
            padding: 20px;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .view.active {
            display: block;
            opacity: 1;
        }

        /* Deck Grid */
        .deck-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 16px;
            padding: 4px;
        }

        .deck-card {
            background: var(--card-bg);
            border-radius: var(--radius);
            padding: 20px;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid var(--border-color);
            position: relative;
            overflow: hidden;
        }

        .deck-card:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow);
            border-color: var(--accent);
        }

        .deck-card:active {
            transform: translateY(0);
        }

        .deck-name {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        .deck-stats {
            display: flex;
            gap: 12px;
            font-size: 13px;
            color: var(--text-secondary);
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        /* Flashcard */
        .flashcard-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }

        .flashcard {
            background: var(--card-bg);
            border-radius: var(--radius);
            padding: 40px;
            width: 100%;
            min-height: 400px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            box-shadow: var(--shadow);
            border: 1px solid var(--border-color);
            cursor: pointer;
            position: relative;
            overflow-wrap: break-word;
            word-break: break-word;
        }

        .flashcard-content {
            font-size: 20px;
            line-height: 1.6;
            width: 100%;
        }

        /* Answer Buttons */
        .answer-buttons {
            display: flex;
            gap: 12px;
            margin-top: 30px;
            width: 100%;
            max-width: 600px;
        }

        .answer-btn {
            flex: 1;
            padding: 16px;
            border-radius: var(--radius);
            border: none;
            font-weight: 600;
            font-size: 15px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
        }

        .answer-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .answer-btn:active {
            transform: translateY(0);
        }

        .btn-again { background: var(--danger); }
        .btn-hard { background: var(--warning); }
        .btn-good { background: var(--success); }
        .btn-easy { background: var(--accent); }

        .answer-time {
            font-size: 11px;
            opacity: 0.9;
            margin-top: 4px;
            font-weight: normal;
        }

        /* Add Card Form */
        .form-container {
            max-width: 600px;
            margin: 0 auto;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text-secondary);
            font-size: 14px;
        }

        .form-input,
        .form-textarea,
        .form-select {
            width: 100%;
            padding: 12px 16px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            color: var(--text-primary);
            font-size: 16px;
            font-family: inherit;
            transition: border-color 0.2s;
        }

        .form-input:focus,
        .form-textarea:focus,
        .form-select:focus {
            outline: none;
            border-color: var(--accent);
        }

        .form-textarea {
            min-height: 120px;
            resize: vertical;
            line-height: 1.5;
        }

        .form-button {
            width: 100%;
            padding: 16px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: var(--radius);
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .form-button:hover {
            background: var(--accent-hover);
        }

        /* Cloze Styles */
        .cloze {
            color: var(--accent);
            font-weight: 600;
            background: rgba(10, 132, 255, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid rgba(10, 132, 255, 0.3);
        }

        .cloze-blank {
            color: var(--accent);
            font-weight: 600;
            background: rgba(10, 132, 255, 0.05);
            padding: 2px 8px;
            border-radius: 4px;
            border: 2px dashed var(--accent);
            display: inline-block;
            min-width: 60px;
            cursor: pointer;
        }

        /* Progress */
        .progress-bar {
            height: 4px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: var(--accent);
            transition: width 0.3s ease;
            border-radius: 2px;
        }

        /* Stats Cards */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-top: 20px;
        }

        .stat-card {
            background: var(--card-bg);
            border-radius: var(--radius);
            padding: 24px;
            text-align: center;
            border: 1px solid var(--border-color);
        }

        .stat-value {
            font-size: 36px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .stat-label {
            font-size: 14px;
            color: var(--text-secondary);
        }

        /* Utility */
        .hidden {
            display: none !important;
        }

        .text-center {
            text-align: center;
        }

        .mb-3 {
            margin-bottom: 12px;
        }

        .mb-4 {
            margin-bottom: 16px;
        }

        .mt-3 {
            margin-top: 12px;
        }

        .mt-4 {
            margin-top: 16px;
        }

        .ml-2 {
            margin-left: 8px;
        }

        .mr-2 {
            margin-right: 8px;
        }

        .space-y-4 > * + * {
            margin-top: 16px;
        }

        /* FAB */
        .fab {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 56px;
            height: 56px;
            border-radius: 28px;
            background: var(--accent);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            cursor: pointer;
            border: none;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            transition: all 0.2s;
            z-index: 1000;
        }

        .fab:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 24px rgba(0, 0, 0, 0.3);
        }

        /* Loading */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--bg-tertiary);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-secondary);
        }

        .empty-icon {
            font-size: 48px;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        /* Card Actions */
        .card-actions {
            position: absolute;
            top: 16px;
            right: 16px;
            display: flex;
            gap: 8px;
        }

        .card-action-btn {
            width: 32px;
            height: 32px;
            border-radius: 16px;
            background: rgba(0,0,0,0.1);
            border: none;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background 0.2s;
        }

        .card-action-btn:hover {
            background: rgba(0,0,0,0.2);
        }

        /* Study Info */
        .study-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 0 4px;
        }

        .study-counts {
            display: flex;
            gap: 16px;
        }

        .study-count {
            font-size: 14px;
            font-weight: 600;
            padding: 4px 8px;
            border-radius: 6px;
            background: var(--bg-tertiary);
        }

        .study-timer {
            font-size: 14px;
            font-family: monospace;
            color: var(--text-secondary);
        }

        /* Browser */
        .browser-item {
            background: var(--card-bg);
            border-radius: var(--radius);
            padding: 16px;
            margin-bottom: 12px;
            border: 1px solid var(--border-color);
            transition: border-color 0.2s;
        }

        .browser-item:hover {
            border-color: var(--accent);
        }

        /* Cloze Hint */
        .cloze-hint {
            font-size: 13px;
            color: var(--text-secondary);
            margin-top: 8px;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            border-left: 3px solid var(--accent);
        }

        .cloze-hint i {
            margin-right: 6px;
        }

        /* Alert */
        .alert {
            padding: 12px 16px;
            border-radius: var(--radius);
            margin-bottom: 20px;
            border: 1px solid transparent;
        }

        .alert-error {
            background: rgba(255, 69, 58, 0.1);
            border-color: rgba(255, 69, 58, 0.3);
            color: var(--danger);
        }

        .alert-success {
            background: rgba(50, 215, 75, 0.1);
            border-color: rgba(50, 215, 75, 0.3);
            color: var(--success);
        }

        /* Tooltip */
        [data-tooltip] {
            position: relative;
        }

        [data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            padding: 6px 12px;
            background: rgba(0,0,0,0.8);
            color: white;
            font-size: 12px;
            border-radius: 4px;
            white-space: nowrap;
            margin-bottom: 8px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading" id="loading">
        <div class="loading-spinner"></div>
        <div>Loading Anki...</div>
    </div>

    <!-- Main Container -->
    <div class="container hidden" id="app">
        <!-- Header -->
        <div class="header">
            <h1 class="text-xl font-bold">Anki</h1>
            <div class="nav">
                <div class="nav-item active" data-view="decks">Decks</div>
                <div class="nav-item" data-view="add">Add</div>
                <div class="nav-item" data-view="browse">Browse</div>
                <div class="nav-item" data-view="stats">Stats</div>
            </div>
            <div></div> <!-- Spacer for balance -->
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <!-- Decks View -->
            <div class="view active" id="view-decks">
                <div class="deck-grid" id="deck-list"></div>
                <button class="fab" id="add-deck-btn" data-tooltip="Add Deck">
                    <i class="fa-solid fa-plus"></i>
                </button>
            </div>

            <!-- Study View -->
            <div class="view" id="view-study">
                <div class="study-info">
                    <div class="study-counts">
                        <span class="study-count text-blue-400" id="count-new">0</span>
                        <span class="study-count text-yellow-400" id="count-learn">0</span>
                        <span class="study-count text-green-400" id="count-review">0</span>
                    </div>
                    <div class="study-timer" id="timer">00:00</div>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
                </div>
                <div class="flashcard-container">
                    <div class="flashcard" id="flashcard">
                        <div class="card-actions">
                            <button class="card-action-btn" onclick="ankiApp.editCard()" data-tooltip="Edit">
                                <i class="fa-solid fa-pen"></i>
                            </button>
                            <button class="card-action-btn" onclick="ankiApp.deleteCard()" data-tooltip="Delete">
                                <i class="fa-solid fa-trash"></i>
                            </button>
                        </div>
                        <div class="flashcard-content" id="card-content">
                            Tap the card to begin studying...
                        </div>
                    </div>
                </div>
                <div class="answer-buttons hidden" id="answer-buttons">
                    <button class="answer-btn btn-again" onclick="ankiApp.answer(1)">
                        Again
                        <span class="answer-time" id="time-again">1m</span>
                    </button>
                    <button class="answer-btn btn-hard" onclick="ankiApp.answer(2)">
                        Hard
                        <span class="answer-time" id="time-hard">10m</span>
                    </button>
                    <button class="answer-btn btn-good" onclick="ankiApp.answer(3)">
                        Good
                        <span class="answer-time" id="time-good">1d</span>
                    </button>
                    <button class="answer-btn btn-easy" onclick="ankiApp.answer(4)">
                        Easy
                        <span class="answer-time" id="time-easy">4d</span>
                    </button>
                </div>
                <button class="form-button mt-4 hidden" id="show-answer-btn" onclick="ankiApp.showAnswer()">
                    Show Answer
                </button>
            </div>

            <!-- Add Card View -->
            <div class="view" id="view-add">
                <div class="form-container">
                    <h2 class="text-2xl font-bold mb-6">Add New Card</h2>
                    
                    <div class="form-group">
                        <label class="form-label">Deck</label>
                        <select class="form-select" id="deck-select">
                            <option value="">Select deck...</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Card Type</label>
                        <select class="form-select" id="card-type" onchange="ankiApp.updateCardType()">
                            <option value="basic">Basic</option>
                            <option value="basic-rev">Basic (and reversed card)</option>
                            <option value="cloze">Cloze</option>
                            <option value="cloze+">Cloze+ (Multiple deletions)</option>
                        </select>
                    </div>

                    <div id="fields-container">
                        <div class="form-group">
                            <label class="form-label" id="front-label">Front</label>
                            <textarea class="form-textarea" id="front-field" rows="4" 
                                      placeholder="Enter question or text..."></textarea>
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label" id="back-label">Back</label>
                            <textarea class="form-textarea" id="back-field" rows="4" 
                                      placeholder="Enter answer or additional information..."></textarea>
                        </div>
                    </div>

                    <div class="cloze-hint hidden" id="cloze-hint">
                        <i class="fa-solid fa-lightbulb"></i>
                        Use {{c1::cloze}} syntax for deletions. Example: "The {{c1::capital}} of France is {{c2::Paris}}."
                    </div>

                    <button class="form-button" onclick="ankiApp.saveCard()">
                        <i class="fa-solid fa-plus mr-2"></i>Add Card
                    </button>
                </div>
            </div>

            <!-- Browse View -->
            <div class="view" id="view-browse">
                <div class="form-container">
                    <input type="text" class="form-input mb-4" id="search-input" 
                           placeholder="Search cards..." oninput="ankiApp.searchCards()">
                    <div id="browse-list"></div>
                </div>
            </div>

            <!-- Stats View -->
            <div class="view" id="view-stats">
                <div class="form-container">
                    <h2 class="text-2xl font-bold mb-6">Statistics</h2>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-value text-blue-400" id="stat-total">0</div>
                            <div class="stat-label">Total Cards</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value text-green-400" id="stat-due">0</div>
                            <div class="stat-label">Due Today</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value text-yellow-400" id="stat-learn">0</div>
                            <div class="stat-label">Learning</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value text-purple-400" id="stat-review">0</div>
                            <div class="stat-label">To Review</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
    // ============================================================================
    // ANKI iOS - Complete Implementation
    // Made by ©️Muhammad Daler
    // ============================================================================

    class AnkiDB {
        constructor() {
            this.db = null;
            this.DB_NAME = 'AnkiIOSDB';
            this.DB_VERSION = 5; // Increased version for schema updates
        }

        async init() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);
                
                request.onerror = () => reject(request.error);
                
                request.onupgradeneeded = (event) => {
                    console.log('Database upgrade needed:', event.oldVersion, '→', event.newVersion);
                    const db = event.target.result;
                    
                    // Create object stores if they don't exist
                    const storeNames = ['decks', 'notes', 'cards', 'revlog'];
                    
                    storeNames.forEach(storeName => {
                        if (!db.objectStoreNames.contains(storeName)) {
                            console.log('Creating store:', storeName);
                            const store = db.createObjectStore(storeName, { keyPath: 'id' });
                            
                            // Create indexes
                            switch(storeName) {
                                case 'decks':
                                    store.createIndex('name', 'name', { unique: true });
                                    break;
                                case 'notes':
                                    store.createIndex('deckId', 'deckId');
                                    store.createIndex('type', 'type');
                                    break;
                                case 'cards':
                                    store.createIndex('deckId', 'deckId');
                                    store.createIndex('noteId', 'noteId');
                                    store.createIndex('due', 'due');
                                    store.createIndex('type', 'type');
                                    store.createIndex('clozeNumber', 'clozeNumber');
                                    store.createIndex('queue', 'queue');
                                    break;
                                case 'revlog':
                                    store.createIndex('cardId', 'cardId');
                                    store.createIndex('time', 'time');
                                    break;
                            }
                        }
                    });
                };
                
                request.onsuccess = (event) => {
                    this.db = event.target.result;
                    console.log('Database initialized successfully');
                    resolve(this);
                };
            });
        }

        // CRUD operations
        async add(storeName, data) {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction([storeName], 'readwrite');
                const store = tx.objectStore(storeName);
                const request = store.add(data);
                
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async get(storeName, id) {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction([storeName], 'readonly');
                const store = tx.objectStore(storeName);
                const request = store.get(id);
                
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async getAll(storeName) {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction([storeName], 'readonly');
                const store = tx.objectStore(storeName);
                const request = store.getAll();
                
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async put(storeName, data) {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction([storeName], 'readwrite');
                const store = tx.objectStore(storeName);
                const request = store.put(data);
                
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        async delete(storeName, id) {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction([storeName], 'readwrite');
                const store = tx.objectStore(storeName);
                const request = store.delete(id);
                
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        async getCardsByDeck(deckId) {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction(['cards'], 'readonly');
                const store = tx.objectStore('cards');
                const index = store.index('deckId');
                const request = index.getAll(deckId);
                
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async getNotesByDeck(deckId) {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction(['notes'], 'readonly');
                const store = tx.objectStore('notes');
                const index = store.index('deckId');
                const request = index.getAll(deckId);
                
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }
    }

    // ============================================================================
    // SM-2 Scheduler (Anki's Algorithm)
    // ============================================================================

    class Scheduler {
        static MINUTE = 60;
        static HOUR = 3600;
        static DAY = 86400;

        // SM-2 algorithm implementation
        static calculate(card, ease, rating) {
            const now = Math.floor(Date.now() / 1000);
            const today = Math.floor(now / this.DAY);
            
            let newEase = ease;
            let newInterval = card.interval || 0;
            let newDue = card.due || 0;
            let newType = card.type || 0;
            let newQueue = card.queue || 0;
            
            // Learning phase
            if (card.type === 0) { // New card
                if (rating >= 3) {
                    newType = 2; // Review card
                    newInterval = 1; // 1 day
                    newDue = today + newInterval;
                    newQueue = 2; // Review queue
                } else {
                    newType = 1; // Learning card
                    newInterval = 1; // 1 minute
                    newDue = now + (newInterval * this.MINUTE);
                    newQueue = 1; // Learning queue
                }
            }
            // Review phase
            else if (card.type === 2) {
                if (rating === 1) { // Again
                    newType = 1; // Relearning
                    newEase = Math.max(1300, ease - 200);
                    newInterval = 1; // 1 minute
                    newDue = now + (newInterval * this.MINUTE);
                    newQueue = 1;
                } else {
                    // Calculate new interval
                    if (rating === 2) { // Hard
                        newEase = Math.max(1300, ease - 150);
                        newInterval = Math.max(1, Math.floor(card.interval * 1.2));
                    } else if (rating === 3) { // Good
                        newInterval = Math.max(1, Math.floor(card.interval * (ease / 1000)));
                    } else if (rating === 4) { // Easy
                        newEase = Math.min(5000, ease + 150);
                        newInterval = Math.max(1, Math.floor(card.interval * (ease / 1000) * 1.3));
                    }
                    
                    newDue = today + newInterval;
                    newQueue = 2;
                }
            }
            // Relearning phase
            else if (card.type === 1) {
                if (rating >= 3) {
                    newType = 2; // Back to review
                    newInterval = 1; // 1 day
                    newDue = today + newInterval;
                    newQueue = 2;
                } else {
                    newInterval = 1; // 1 minute
                    newDue = now + (newInterval * this.MINUTE);
                    newQueue = 1;
                }
            }
            
            return {
                ease: newEase,
                interval: newInterval,
                due: newDue,
                type: newType,
                queue: newQueue,
                reviews: (card.reviews || 0) + 1,
                lapses: rating === 1 ? (card.lapses || 0) + 1 : (card.lapses || 0)
            };
        }

        static formatInterval(interval, isReview = false) {
            if (!isReview && interval < this.DAY) {
                if (interval < this.MINUTE) return `${interval}s`;
                if (interval < this.HOUR) return `${Math.floor(interval / this.MINUTE)}m`;
                return `${Math.floor(interval / this.HOUR)}h`;
            }
            
            const days = isReview ? interval : Math.floor(interval / this.DAY);
            if (days < 30) return `${days}d`;
            if (days < 365) return `${Math.floor(days / 30)}mo`;
            return `${Math.floor(days / 365)}y`;
        }

        static getNextReviewTime(card, rating) {
            const result = this.calculate(card, card.ease || 2500, rating);
            return this.formatInterval(result.interval, card.type === 2);
        }
    }

    // ============================================================================
    // ANKI APP
    // ============================================================================

    class AnkiApp {
        constructor() {
            this.db = new AnkiDB();
            this.currentDeck = null;
            this.studyQueue = [];
            this.currentCard = null;
            this.currentNote = null;
            this.isAnswerShown = false;
            this.startTime = null;
            this.timerInterval = null;
            this.totalCards = 0;
            this.cardsStudied = 0;
            
            this.init();
        }

        async init() {
            try {
                // Initialize database
                await this.db.init();
                
                // Create default deck if needed
                await this.ensureDefaultDeck();
                
                // Setup event listeners
                this.setupEventListeners();
                
                // Update UI
                await this.updateDeckSelect();
                await this.renderDeckList();
                await this.updateStats();
                
                // Hide loading screen
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('app').classList.remove('hidden');
                
                console.log('Anki App initialized successfully');
            } catch (error) {
                console.error('Failed to initialize app:', error);
                alert('Failed to initialize app. Please refresh the page.');
            }
        }

        async ensureDefaultDeck() {
            const decks = await this.db.getAll('decks');
            if (decks.length === 0) {
                const defaultDeck = {
                    id: Date.now(),
                    name: 'Default',
                    created: Date.now(),
                    desc: 'Your default deck'
                };
                await this.db.add('decks', defaultDeck);
                
                // Add sample cards
                await this.addSampleCards(defaultDeck.id);
            }
        }

        async addSampleCards(deckId) {
            // Sample Basic Card
            const note1 = {
                id: Date.now(),
                deckId: deckId,
                type: 'basic',
                front: 'What is the capital of France?',
                back: 'Paris',
                tags: ['geography'],
                created: Date.now()
            };
            await this.db.add('notes', note1);
            
            const card1 = {
                id: Date.now() + 1,
                noteId: note1.id,
                deckId: deckId,
                ord: 0,
                type: 0,
                queue: 0,
                due: 0,
                interval: 0,
                ease: 2500,
                factor: 2500,
                reps: 0,
                lapses: 0,
                left: 0,
                odue: 0,
                odid: 0,
                flags: 0,
                data: '',
                created: Date.now()
            };
            await this.db.add('cards', card1);
            
            // Sample Cloze Card
            const note2 = {
                id: Date.now() + 2,
                deckId: deckId,
                type: 'cloze',
                front: 'The {{c1::capital}} of France is {{c2::Paris}}.',
                back: 'France is located in Western Europe.',
                tags: ['geography'],
                created: Date.now()
            };
            await this.db.add('notes', note2);
            
            // Create cloze cards
            const clozeNumbers = [1, 2];
            for (let i = 0; i < clozeNumbers.length; i++) {
                const card = {
                    id: Date.now() + 3 + i,
                    noteId: note2.id,
                    deckId: deckId,
                    ord: i,
                    type: 0,
                    queue: 0,
                    due: 0,
                    interval: 0,
                    ease: 2500,
                    factor: 2500,
                    reps: 0,
                    lapses: 0,
                    left: 0,
                    odue: 0,
                    odid: 0,
                    flags: 0,
                    data: '',
                    clozeNumber: clozeNumbers[i],
                    created: Date.now()
                };
                await this.db.add('cards', card);
            }
        }

        // ============================================================================
        // NAVIGATION
        // ============================================================================

        setupEventListeners() {
            // Navigation tabs
            document.querySelectorAll('.nav-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    const view = e.target.dataset.view;
                    this.switchView(view);
                });
            });
            
            // Add deck button
            document.getElementById('add-deck-btn').addEventListener('click', () => {
                this.createDeck();
            });
            
            // Flashcard click
            document.getElementById('flashcard').addEventListener('click', () => {
                if (!this.isAnswerShown) {
                    this.showAnswer();
                }
            });
            
            // Search input
            document.getElementById('search-input').addEventListener('input', (e) => {
                this.searchCards(e.target.value);
            });
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                // Ignore if typing in input
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    return;
                }
                
                const activeView = document.querySelector('.view.active').id;
                
                if (activeView === 'view-study') {
                    if (!this.isAnswerShown && e.code === 'Space') {
                        this.showAnswer();
                        e.preventDefault();
                    } else if (this.isAnswerShown) {
                        switch(e.code) {
                            case 'Digit1': this.answer(1); break;
                            case 'Digit2': this.answer(2); break;
                            case 'Digit3': this.answer(3); break;
                            case 'Digit4': this.answer(4); break;
                            case 'Enter': this.answer(3); break;
                        }
                    }
                }
            });
        }

        switchView(view) {
            // Update navigation
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
                if (item.dataset.view === view) {
                    item.classList.add('active');
                }
            });
            
            // Hide all views
            document.querySelectorAll('.view').forEach(view => {
                view.classList.remove('active');
            });
            
            // Show selected view
            const targetView = document.getElementById(`view-${view}`);
            if (targetView) {
                targetView.classList.add('active');
                
                // Update view-specific data
                switch(view) {
                    case 'decks':
                        this.renderDeckList();
                        break;
                    case 'browse':
                        this.searchCards();
                        break;
                    case 'stats':
                        this.updateStats();
                        break;
                }
            }
        }

        // ============================================================================
        // DECK MANAGEMENT
        // ============================================================================

        async renderDeckList() {
            const container = document.getElementById('deck-list');
            container.innerHTML = '';
            
            try {
                const decks = await this.db.getAll('decks');
                const allCards = await this.db.getAll('cards');
                
                if (decks.length === 0) {
                    container.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-icon">
                                <i class="fa-solid fa-layer-group"></i>
                            </div>
                            <h3 class="text-lg font-medium mb-2">No Decks</h3>
                            <p class="text-gray-500 mb-4">Create your first deck to get started</p>
                            <button class="form-button" onclick="ankiApp.createDeck()">
                                Create Deck
                            </button>
                        </div>
                    `;
                    return;
                }
                
                const now = Math.floor(Date.now() / 1000);
                const today = Math.floor(now / 86400);
                
                for (const deck of decks) {
                    const deckCards = allCards.filter(card => card.deckId === deck.id);
                    
                    // Calculate statistics
                    const newCards = deckCards.filter(c => c.type === 0).length;
                    const learningCards = deckCards.filter(c => 
                        (c.type === 1 || c.type === 3) && c.due < now
                    ).length;
                    const reviewCards = deckCards.filter(c => 
                        c.type === 2 && c.due <= today
                    ).length;
                    
                    const deckElement = document.createElement('div');
                    deckElement.className = 'deck-card';
                    deckElement.innerHTML = `
                        <div class="deck-name">${this.escapeHtml(deck.name)}</div>
                        <div class="deck-stats">
                            <div class="stat-item">
                                <span class="text-blue-400">${newCards}</span>
                                <span class="text-gray-500">new</span>
                            </div>
                            <div class="stat-item">
                                <span class="text-yellow-400">${learningCards}</span>
                                <span class="text-gray-500">learn</span>
                            </div>
                            <div class="stat-item">
                                <span class="text-green-400">${reviewCards}</span>
                                <span class="text-gray-500">review</span>
                            </div>
                        </div>
                    `;
                    
                    deckElement.addEventListener('click', () => this.studyDeck(deck.id));
                    container.appendChild(deckElement);
                }
            } catch (error) {
                console.error('Error rendering deck list:', error);
                container.innerHTML = '<div class="alert alert-error">Error loading decks</div>';
            }
        }

        async createDeck() {
            const name = prompt('Enter deck name:');
            if (!name || !name.trim()) return;
            
            try {
                const deck = {
                    id: Date.now(),
                    name: name.trim(),
                    created: Date.now(),
                    desc: ''
                };
                
                await this.db.add('decks', deck);
                
                // Update UI
                await this.updateDeckSelect();
                await this.renderDeckList();
                await this.updateStats();
                
                this.showAlert('Deck created successfully!', 'success');
            } catch (error) {
                console.error('Error creating deck:', error);
                this.showAlert('Failed to create deck', 'error');
            }
        }

        async updateDeckSelect() {
            const select = document.getElementById('deck-select');
            select.innerHTML = '<option value="">Select deck...</option>';
            
            try {
                const decks = await this.db.getAll('decks');
                decks.forEach(deck => {
                    const option = document.createElement('option');
                    option.value = deck.id;
                    option.textContent = deck.name;
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('Error loading decks:', error);
            }
        }

        // ============================================================================
        // STUDY SESSION
        // ============================================================================

        async studyDeck(deckId) {
            try {
                this.currentDeck = deckId;
                await this.buildStudyQueue(deckId);
                
                if (this.studyQueue.length === 0) {
                    this.showAlert('No cards to study right now!', 'error');
                    return;
                }
                
                // Update counts display
                const now = Math.floor(Date.now() / 1000);
                const today = Math.floor(now / 86400);
                const deckCards = await this.db.getCardsByDeck(deckId);
                
                const newCount = deckCards.filter(c => c.type === 0).length;
                const learnCount = deckCards.filter(c => 
                    (c.type === 1 || c.type === 3) && c.due < now
                ).length;
                const reviewCount = deckCards.filter(c => c.type === 2 && c.due <= today).length;
                
                document.getElementById('count-new').textContent = newCount;
                document.getElementById('count-learn').textContent = learnCount;
                document.getElementById('count-review').textContent = reviewCount;
                
                // Start study session
                this.totalCards = this.studyQueue.length;
                this.cardsStudied = 0;
                this.startTime = Date.now();
                this.startTimer();
                
                // Switch to study view
                this.switchView('study');
                await this.showNextCard();
                
            } catch (error) {
                console.error('Error starting study session:', error);
                this.showAlert('Failed to start study session', 'error');
            }
        }

        async buildStudyQueue(deckId) {
            try {
                const cards = await this.db.getCardsByDeck(deckId);
                const now = Math.floor(Date.now() / 1000);
                const today = Math.floor(now / 86400);
                
                // Sort cards: learning > review > new
                const learningCards = cards.filter(card => 
                    (card.type === 1 || card.type === 3) && card.due < now
                ).sort((a, b) => a.due - b.due);
                
                const reviewCards = cards.filter(card => 
                    card.type === 2 && card.due <= today
                ).sort((a, b) => a.due - b.due);
                
                const newCards = cards.filter(card => card.type === 0);
                
                // Shuffle new cards
                this.shuffleArray(newCards);
                
                this.studyQueue = [...learningCards, ...reviewCards, ...newCards.slice(0, 20)];
                
            } catch (error) {
                console.error('Error building study queue:', error);
                this.studyQueue = [];
            }
        }

        async showNextCard() {
            if (this.studyQueue.length === 0) {
                await this.endStudySession();
                return;
            }
            
            this.currentCard = this.studyQueue.shift();
            this.currentNote = await this.db.get('notes', this.currentCard.noteId);
            this.isAnswerShown = false;
            
            if (!this.currentNote) {
                console.error('Note not found for card:', this.currentCard);
                await this.showNextCard();
                return;
            }
            
            this.renderCardFront();
            
            // Update UI
            document.getElementById('answer-buttons').classList.add('hidden');
            document.getElementById('show-answer-btn').classList.remove('hidden');
            
            // Update progress
            this.cardsStudied++;
            this.updateProgress();
        }

        renderCardFront() {
            const container = document.getElementById('card-content');
            
            if (!this.currentNote) {
                container.innerHTML = '<div class="alert alert-error">Error loading card</div>';
                return;
            }
            
            let content = '';
            
            switch(this.currentNote.type) {
                case 'cloze':
                case 'cloze+':
                    content = this.renderClozeFront();
                    break;
                case 'basic-rev':
                    if (this.currentCard.ord === 1) {
                        content = this.formatText(this.currentNote.back || '');
                    } else {
                        content = this.formatText(this.currentNote.front);
                    }
                    break;
                default:
                    content = this.formatText(this.currentNote.front);
            }
            
            container.innerHTML = content;
        }

        renderClozeFront() {
            let text = this.currentNote.front;
            const clozeNumber = this.currentCard.clozeNumber || 1;
            
            // Hide the current cloze
            const regex = new RegExp(`{{c${clozeNumber}::(.*?)}}`, 'g');
            text = text.replace(regex, (match, content) => {
                // Check for hint
                const parts = content.split('::');
                if (parts.length > 1) {
                    return `<span class="cloze-blank" data-hint="${this.escapeHtml(parts[1])}">[...]</span>`;
                }
                return '<span class="cloze-blank">[...]</span>';
            });
            
            // Show other clozes
            text = text.replace(/{{c\d+::(.*?)}}/g, (match, content) => {
                const parts = content.split('::');
                return this.escapeHtml(parts[0]);
            });
            
            return this.formatText(text);
        }

        showAnswer() {
            if (!this.currentNote || this.isAnswerShown) return;
            
            this.isAnswerShown = true;
            const container = document.getElementById('card-content');
            
            let content = '';
            
            switch(this.currentNote.type) {
                case 'cloze':
                case 'cloze+':
                    content = this.renderClozeAnswer();
                    break;
                case 'basic-rev':
                    if (this.currentCard.ord === 1) {
                        content = `
                            <div class="text-xl mb-8">${this.formatText(this.currentNote.back || '')}</div>
                            <div class="border-t border-gray-400 pt-6">
                                <div class="text-sm text-gray-500 mb-2">Answer:</div>
                                <div class="text-lg">${this.formatText(this.currentNote.front)}</div>
                            </div>
                        `;
                    } else {
                        content = `
                            <div class="text-xl mb-8">${this.formatText(this.currentNote.front)}</div>
                            <div class="border-t border-gray-400 pt-6">
                                <div class="text-sm text-gray-500 mb-2">Answer:</div>
                                <div class="text-lg">${this.formatText(this.currentNote.back || '')}</div>
                            </div>
                        `;
                    }
                    break;
                default:
                    content = `
                        <div class="text-xl mb-8">${this.formatText(this.currentNote.front)}</div>
                        <div class="border-t border-gray-400 pt-6">
                            <div class="text-sm text-gray-500 mb-2">Answer:</div>
                            <div class="text-lg">${this.formatText(this.currentNote.back || '')}</div>
                        </div>
                    `;
            }
            
            container.innerHTML = content;
            
            // Update UI
            document.getElementById('show-answer-btn').classList.add('hidden');
            document.getElementById('answer-buttons').classList.remove('hidden');
            
            // Update button times
            this.updateAnswerButtonTimes();
        }

        renderClozeAnswer() {
            let text = this.currentNote.front;
            const clozeNumber = this.currentCard.clozeNumber || 1;
            
            // Highlight current cloze
            const regex = new RegExp(`{{c${clozeNumber}::(.*?)}}`, 'g');
            text = text.replace(regex, (match, content) => {
                const parts = content.split('::');
                return `<span class="cloze">${this.escapeHtml(parts[0])}</span>`;
            });
            
            // Show other clozes
            text = text.replace(/{{c\d+::(.*?)}}/g, (match, content) => {
                const parts = content.split('::');
                return this.escapeHtml(parts[0]);
            });
            
            let content = `<div class="text-xl mb-8">${this.formatText(text)}</div>`;
            
            // Add back content if exists
            if (this.currentNote.back && this.currentNote.back.trim()) {
                content += `
                    <div class="border-t border-gray-400 pt-6">
                        <div class="text-sm text-gray-500 mb-2">Additional Information:</div>
                        <div>${this.formatText(this.currentNote.back)}</div>
                    </div>
                `;
            }
            
            return content;
        }

        async answer(rating) {
            try {
                if (!this.currentCard) return;
                
                // Calculate new card state
                const updatedCard = Scheduler.calculate(
                    this.currentCard,
                    this.currentCard.ease || 2500,
                    rating
                );
                
                // Merge with current card
                const newCard = {
                    ...this.currentCard,
                    ...updatedCard,
                    lastReviewed: Date.now()
                };
                
                // Save updated card
                await this.db.put('cards', newCard);
                
                // Log review
                const reviewTime = Math.floor((Date.now() - this.startTime) / 1000);
                await this.db.add('revlog', {
                    id: Date.now(),
                    cardId: this.currentCard.id,
                    ease: rating,
                    time: reviewTime,
                    type: newCard.type,
                    ivl: newCard.interval,
                    lastIvl: this.currentCard.interval,
                    factor: newCard.ease,
                    created: Date.now()
                });
                
                // Reset timer for next card
                this.startTime = Date.now();
                
                // Show next card
                await this.showNextCard();
                
            } catch (error) {
                console.error('Error answering card:', error);
                this.showAlert('Failed to save answer', 'error');
            }
        }

        updateAnswerButtonTimes() {
            if (!this.currentCard) return;
            
            const ratings = [1, 2, 3, 4];
            ratings.forEach(rating => {
                const time = Scheduler.getNextReviewTime(this.currentCard, rating);
                const element = document.getElementById(`time-${['again', 'hard', 'good', 'easy'][rating - 1]}`);
                if (element) {
                    element.textContent = time;
                }
            });
        }

        updateProgress() {
            const progress = (this.cardsStudied / this.totalCards) * 100;
            document.getElementById('progress-fill').style.width = `${progress}%`;
        }

        startTimer() {
            this.stopTimer();
            
            this.timerInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                document.getElementById('timer').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }, 1000);
        }

        stopTimer() {
            if (this.timerInterval) {
                clearInterval(this.timerInterval);
                this.timerInterval = null;
            }
        }

        async endStudySession() {
            this.stopTimer();
            
            const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            
            let message = `Study session complete!\n\n`;
            message += `Cards studied: ${this.cardsStudied}\n`;
            message += `Time spent: ${minutes} minute${minutes !== 1 ? 's' : ''}\n\n`;
            message += `Great job! 🎉`;
            
            alert(message);
            
            // Update stats and return to decks
            await this.updateStats();
            await this.renderDeckList();
            this.switchView('decks');
        }

        // ============================================================================
        // CARD MANAGEMENT
        // ============================================================================

        updateCardType() {
            const type = document.getElementById('card-type').value;
            const hint = document.getElementById('cloze-hint');
            const frontLabel = document.getElementById('front-label');
            
            if (type === 'cloze' || type === 'cloze+') {
                hint.classList.remove('hidden');
                frontLabel.textContent = 'Text (use {{c1::cloze}} syntax)';
                document.getElementById('front-field').placeholder = 
                    'Example: The {{c1::capital}} of France is {{c2::Paris}}.';
            } else {
                hint.classList.add('hidden');
                frontLabel.textContent = 'Front';
                document.getElementById('front-field').placeholder = 'Enter question or text...';
            }
        }

        async saveCard() {
            try {
                const deckId = document.getElementById('deck-select').value;
                const cardType = document.getElementById('card-type').value;
                const front = document.getElementById('front-field').value.trim();
                const back = document.getElementById('back-field').value.trim();
                
                // Validation
                if (!deckId) {
                    this.showAlert('Please select a deck', 'error');
                    return;
                }
                
                if (!front) {
                    this.showAlert('Front field is required', 'error');
                    return;
                }
                
                if ((cardType === 'basic' || cardType === 'basic-rev') && !back) {
                    this.showAlert('Back field is required for basic cards', 'error');
                    return;
                }
                
                // Create note
                const noteId = Date.now();
                const note = {
                    id: noteId,
                    deckId: parseInt(deckId),
                    type: cardType,
                    front: front,
                    back: back,
                    tags: [],
                    created: Date.now()
                };
                
                await this.db.add('notes', note);
                
                // Create cards based on type
                if (cardType === 'basic') {
                    await this.createCard(noteId, deckId, 0);
                } 
                else if (cardType === 'basic-rev') {
                    await this.createCard(noteId, deckId, 0); // Front
                    await this.createCard(noteId, deckId, 1); // Back (reversed)
                }
                else if (cardType === 'cloze' || cardType === 'cloze+') {
                    await this.createClozeCards(noteId, deckId, front);
                }
                
                // Clear form
                document.getElementById('front-field').value = '';
                document.getElementById('back-field').value = '';
                
                this.showAlert('Card added successfully!', 'success');
                
                // Update UI
                await this.updateStats();
                await this.renderDeckList();
                
            } catch (error) {
                console.error('Error saving card:', error);
                this.showAlert('Failed to save card: ' + error.message, 'error');
            }
        }

        async createCard(noteId, deckId, ord) {
            const card = {
                id: Date.now() + ord,
                noteId: noteId,
                deckId: parseInt(deckId),
                ord: ord,
                type: 0, // New
                queue: 0,
                due: 0,
                interval: 0,
                ease: 2500,
                factor: 2500,
                reps: 0,
                lapses: 0,
                left: 0,
                odue: 0,
                odid: 0,
                flags: 0,
                data: '',
                created: Date.now()
            };
            
            await this.db.add('cards', card);
        }

        async createClozeCards(noteId, deckId, text) {
            // Extract cloze numbers
            const regex = /{{c(\d+)::(.*?)}}/g;
            const matches = [...text.matchAll(regex)];
            const clozeNumbers = [...new Set(matches.map(m => parseInt(m[1])))];
            
            // If no cloze found, create one card
            if (clozeNumbers.length === 0) {
                clozeNumbers.push(1);
            }
            
            // Create a card for each cloze
            for (let i = 0; i < clozeNumbers.length; i++) {
                const card = {
                    id: Date.now() + i,
                    noteId: noteId,
                    deckId: parseInt(deckId),
                    clozeNumber: clozeNumbers[i],
                    type: 0,
                    queue: 0,
                    due: 0,
                    interval: 0,
                    ease: 2500,
                    factor: 2500,
                    reps: 0,
                    lapses: 0,
                    left: 0,
                    odue: 0,
                    odid: 0,
                    flags: 0,
                    data: '',
                    created: Date.now()
                };
                
                await this.db.add('cards', card);
            }
        }

        async searchCards(query = '') {
            const container = document.getElementById('browse-list');
            container.innerHTML = '';
            
            try {
                const notes = await this.db.getAll('notes');
                const decks = await this.db.getAll('decks');
                const cards = await this.db.getAll('cards');
                
                let filteredNotes = notes;
                if (query) {
                    const searchTerm = query.toLowerCase();
                    filteredNotes = notes.filter(note => 
                        note.front.toLowerCase().includes(searchTerm) ||
                        note.back.toLowerCase().includes(searchTerm)
                    );
                }
                
                if (filteredNotes.length === 0) {
                    container.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-icon">
                                <i class="fa-solid fa-search"></i>
                            </div>
                            <h3 class="text-lg font-medium mb-2">No Cards Found</h3>
                            <p class="text-gray-500">${query ? 'Try a different search term' : 'Add some cards to get started'}</p>
                        </div>
                    `;
                    return;
                }
                
                for (const note of filteredNotes.slice(0, 100)) {
                    const deck = decks.find(d => d.id === note.deckId);
                    const noteCards = cards.filter(c => c.noteId === note.id);
                    
                    const element = document.createElement('div');
                    element.className = 'browser-item';
                    element.innerHTML = `
                        <div class="font-semibold mb-2">${this.formatText(note.front.substring(0, 200))}</div>
                        <div class="text-gray-500 text-sm mb-2">${this.formatText(note.back.substring(0, 100))}</div>
                        <div class="flex justify-between items-center text-xs text-gray-400">
                            <span>${deck ? deck.name : 'Unknown'} • ${note.type} • ${noteCards.length} card(s)</span>
                        </div>
                    `;
                    
                    container.appendChild(element);
                }
            } catch (error) {
                console.error('Error searching cards:', error);
                container.innerHTML = '<div class="alert alert-error">Error loading cards</div>';
            }
        }

        async editCard() {
            if (!this.currentCard || !this.currentNote) {
                this.showAlert('No card selected', 'error');
                return;
            }
            
            this.showAlert('Edit functionality coming soon!', 'error');
        }

        async deleteCard() {
            if (!this.currentCard || !this.currentNote) {
                this.showAlert('No card selected', 'error');
                return;
            }
            
            if (!confirm('Are you sure you want to delete this card?')) {
                return;
            }
            
            try {
                // Delete the card
                await this.db.delete('cards', this.currentCard.id);
                
                // Check if this was the last card for the note
                const cards = await this.db.getAll('cards');
                const noteCards = cards.filter(c => c.noteId === this.currentNote.id);
                
                if (noteCards.length === 0) {
                    await this.db.delete('notes', this.currentNote.id);
                }
                
                // Remove from study queue
                this.studyQueue = this.studyQueue.filter(c => c.id !== this.currentCard.id);
                
                this.showAlert('Card deleted successfully', 'success');
                
                // Show next card or end session
                if (this.studyQueue.length > 0) {
                    await this.showNextCard();
                } else {
                    await this.endStudySession();
                }
                
                // Update stats
                await this.updateStats();
                
            } catch (error) {
                console.error('Error deleting card:', error);
                this.showAlert('Failed to delete card', 'error');
            }
        }

        // ============================================================================
        // STATISTICS
        // ============================================================================

        async updateStats() {
            try {
                const cards = await this.db.getAll('cards');
                const notes = await this.db.getAll('notes');
                const revlogs = await this.db.getAll('revlog');
                
                const now = Math.floor(Date.now() / 1000);
                const today = Math.floor(now / 86400);
                const todayStart = new Date();
                todayStart.setHours(0, 0, 0, 0);
                
                // Calculate statistics
                const totalCards = cards.length;
                
                const dueToday = cards.filter(card => {
                    if (card.type === 0) return true; // New cards
                    if (card.type === 1 || card.type === 3) return card.due < now;
                    if (card.type === 2) return card.due <= today;
                    return false;
                }).length;
                
                const learningCards = cards.filter(card => 
                    (card.type === 1 || card.type === 3) && card.due < now
                ).length;
                
                const reviewCards = cards.filter(card => 
                    card.type === 2 && card.due <= today
                ).length;
                
                // Update UI
                document.getElementById('stat-total').textContent = totalCards;
                document.getElementById('stat-due').textContent = dueToday;
                document.getElementById('stat-learn').textContent = learningCards;
                document.getElementById('stat-review').textContent = reviewCards;
                
            } catch (error) {
                console.error('Error updating stats:', error);
            }
        }

        // ============================================================================
        // UTILITY FUNCTIONS
        // ============================================================================

        formatText(text) {
            if (!text) return '';
            
            return text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/\n/g, '<br>')
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                .replace(/`(.*?)`/g, '<code>$1</code>')
                .replace(/\[(.*?)\]\((.*?)\)/g, '<a href="$2" class="text-blue-400">$1</a>');
        }

        escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        showAlert(message, type = 'info') {
            // Create alert element
            const alert = document.createElement('div');
            alert.className = `alert alert-${type}`;
            alert.innerHTML = `
                <div class="flex items-center justify-between">
                    <span>${message}</span>
                    <button onclick="this.parentElement.parentElement.remove()" class="text-gray-500">
                        <i class="fa-solid fa-times"></i>
                    </button>
                </div>
            `;
            
            // Insert at the beginning of the active view
            const activeView = document.querySelector('.view.active');
            if (activeView) {
                activeView.insertBefore(alert, activeView.firstChild);
                
                // Remove after 5 seconds
                setTimeout(() => {
                    if (alert.parentElement) {
                        alert.remove();
                    }
                }, 5000);
            }
        }
    }

    // ============================================================================
    // INITIALIZE APP
    // ============================================================================

    // Initialize app when page loads
    document.addEventListener('DOMContentLoaded', () => {
        window.ankiApp = new AnkiApp();
    });

    // Make utility functions globally available
    window.formatInterval = (interval) => {
        if (interval < 60) return `${interval}s`;
        if (interval < 3600) return `${Math.floor(interval / 60)}m`;
        if (interval < 86400) return `${Math.floor(interval / 3600)}h`;
        const days = Math.floor(interval / 86400);
        if (days < 30) return `${days}d`;
        if (days < 365) return `${Math.floor(days / 30)}mo`;
        return `${Math.floor(days / 365)}y`;
    };
    </script>
</body>
</html>