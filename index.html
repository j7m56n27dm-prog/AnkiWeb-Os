<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Anki macOS Pro</title>
    
    <!-- PWA Settings -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#F2F2F7" media="(prefers-color-scheme: light)">
    <meta name="theme-color" content="#000000" media="(prefers-color-scheme: dark)">
    <meta name="description" content="Professional flashcard app with spaced repetition">
    <link rel="apple-touch-icon" href="https://cdn-icons-png.flaticon.com/512/3395/3395431.png">
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=SF+Pro+Display:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Libraries -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.9/purify.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        ios: {
                            blue: '#007AFF',
                            green: '#34C759',
                            red: '#FF3B30',
                            orange: '#FF9500',
                            yellow: '#FFCC00',
                            gray: '#8E8E93',
                            gray2: '#AEAEB2',
                            bg: '#F2F2F7',
                            darkBg: '#000000',
                            card: '#FFFFFF',
                            darkCard: '#1C1C1E',
                            separator: '#C6C6C8',
                            darkSeparator: '#38383A',
                        }
                    },
                    fontFamily: {
                        sans: ['-apple-system', 'BlinkMacSystemFont', 'SF Pro Display', 'Helvetica Neue', 'sans-serif'],
                    },
                    animation: {
                        'fade-in': 'fadeIn 0.3s ease-out',
                        'slide-up': 'slideUp 0.3s ease-out',
                        'bounce-in': 'bounceIn 0.5s ease-out',
                    },
                    keyframes: {
                        fadeIn: {
                            '0%': { opacity: '0' },
                            '100%': { opacity: '1' }
                        },
                        slideUp: {
                            '0%': { transform: 'translateY(20px)', opacity: '0' },
                            '100%': { transform: 'translateY(0)', opacity: '1' }
                        },
                        bounceIn: {
                            '0%': { transform: 'scale(0.9)', opacity: '0' },
                            '50%': { transform: 'scale(1.02)' },
                            '100%': { transform: 'scale(1)', opacity: '1' }
                        },
                        spin: {
                            '0%': { transform: 'rotate(0deg)' },
                            '100%': { transform: 'rotate(360deg)' }
                        }
                    }
                }
            }
        };
    </script>
    
    <style>
        /* Global Reset & Typography */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            overscroll-behavior-y: none;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Helvetica Neue', sans-serif;
            background-color: #F2F2F7;
            color: #000000;
            height: 100vh;
            height: 100dvh;
            overflow: hidden;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        body.dark {
            background-color: #000000;
            color: #FFFFFF;
        }
        
        body {
            user-select: none;
        }
        
        input, textarea, [contenteditable] {
            user-select: text;
            -webkit-user-select: text;
        }
        
        /* 3D Flip Animation */
        .card-container {
            perspective: 1200px;
            width: 100%;
            height: 100%;
        }
        
        .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transition: transform 0.6s cubic-bezier(0.2, 0.8, 0.2, 1);
            transform-style: preserve-3d;
        }
        
        .card-flipped {
            transform: rotateY(180deg);
        }
        
        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        .card-back {
            transform: rotateY(180deg);
        }
        
        /* Cloze Styles */
        .cloze-hidden {
            color: transparent;
            background: #007AFF;
            border-radius: 6px;
            padding: 2px 12px;
            font-weight: 600;
            cursor: pointer;
            position: relative;
            display: inline-block;
            min-width: 40px;
            user-select: none;
            -webkit-user-select: none;
            transition: all 0.2s ease;
        }
        
        .cloze-hidden::after {
            content: '...';
            color: white;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.9em;
            letter-spacing: 2px;
        }
        
        body.dark .cloze-hidden {
            background: #0A84FF;
        }
        
        .cloze-revealed {
            color: #34C759;
            font-weight: 700;
            border-bottom: 3px solid rgba(52, 199, 89, 0.4);
            padding: 0 4px;
            animation: clozeReveal 0.4s ease-out;
        }
        
        @keyframes clozeReveal {
            0% { opacity: 0; transform: scale(0.95); }
            100% { opacity: 1; transform: scale(1); }
        }
        
        /* Loader animation */
        .loader {
            width: 24px;
            height: 24px;
            border: 3px solid rgba(128, 128, 128, 0.2);
            border-top-color: #007AFF;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        body.dark .loader {
            border-top-color: #0A84FF;
        }
        
        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        
        ::-webkit-scrollbar-track {
            background: transparent;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #C6C6C8;
            border-radius: 10px;
        }
        
        body.dark ::-webkit-scrollbar-thumb {
            background: #38383A;
        }
        
        /* Safe area support */
        @supports (padding: max(0px)) {
            .safe-area-top {
                padding-top: max(12px, env(safe-area-inset-top));
            }
            .safe-area-bottom {
                padding-bottom: max(12px, env(safe-area-inset-bottom));
            }
        }
        
        /* Button active states */
        button:active {
            opacity: 0.7;
        }
        
        /* Focus states for accessibility */
        button:focus-visible,
        input:focus-visible,
        textarea:focus-visible {
            outline: 2px solid #007AFF;
            outline-offset: 2px;
        }
        
        body.dark button:focus-visible,
        body.dark input:focus-visible,
        body.dark textarea:focus-visible {
            outline: 2px solid #64B5FF;
        }
        
        /* Prevent image dragging */
        img {
            -webkit-user-drag: none;
            user-drag: none;
            pointer-events: none;
        }
        
        /* Card content styling */
        .card-content {
            word-break: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
        }
        
        .card-content p {
            margin-bottom: 0.5em;
        }
        
        .card-content ul, .card-content ol {
            margin-left: 1.5em;
            margin-bottom: 0.5em;
        }
        
        .card-content code {
            background: rgba(0,0,0,0.1);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 0.9em;
        }
        
        body.dark .card-content code {
            background: rgba(255,255,255,0.1);
        }
        
        /* Deck card hover effect */
        .deck-card {
            transition: all 0.2s ease;
        }
        
        .deck-card:hover {
            transform: translateX(4px);
        }
        
        .deck-card:active {
            transform: scale(0.98);
        }
        
        /* Rating button animations */
        .rating-btn {
            transition: all 0.15s ease;
        }
        
        .rating-btn:hover {
            transform: translateY(-2px);
        }
        
        .rating-btn:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body class="transition-colors duration-300">
    <div id="root" class="h-full w-full flex flex-col overflow-hidden"></div>
    
    <script type="text/babel">
        // ============================================
        // 1. CORE UTILITIES & HELPERS
        // ============================================
        
        const { useState, useEffect, useRef, useMemo, useCallback, useContext, createContext, Fragment } = React;
        
        // Theme Context
        const ThemeContext = createContext({ isDark: false, toggleTheme: () => {} });
        
        // Robust ID generator
        const generateId = () => {
            const timestamp = Date.now().toString(36);
            const randomPart = Math.random().toString(36).substring(2, 9);
            const counter = (generateId.counter = (generateId.counter || 0) + 1).toString(36);
            return `${timestamp}-${randomPart}-${counter}`;
        };
        
        // HTML sanitization using DOMPurify
        const sanitize = (text) => {
            if (!text) return '';
            
            // Convert newlines to <br> first
            const htmlWithLineBreaks = text.replace(/\n/g, '<br>');
            
            // Configure DOMPurify with safe settings
            const clean = DOMPurify.sanitize(htmlWithLineBreaks, {
                ALLOWED_TAGS: ['b', 'i', 'u', 'strong', 'em', 'br', 'div', 'span', 'p', 'ul', 'ol', 'li', 'code', 'pre', 'blockquote', 'strike', 'sub', 'sup'],
                ALLOWED_ATTR: ['class', 'title'],
                FORBID_ATTR: ['style', 'onclick', 'onerror'],
                FORBID_TAGS: ['style', 'script', 'iframe', 'object', 'embed', 'form', 'input'],
                USE_PROFILES: { html: true },
                RETURN_DOM_FRAGMENT: false,
            });
            
            return clean;
        };
        
        // Format timestamp to human-readable date
        const formatDate = (timestamp) => {
            const date = new Date(timestamp);
            return date.toLocaleDateString(navigator.language, {
                year: 'numeric',
                month: 'short',
                day: 'numeric'
            });
        };
        
        // Format interval to human-readable
        const formatInterval = (interval) => {
            if (interval < 1) {
                const minutes = Math.round(interval * 24 * 60);
                return minutes <= 1 ? '1m' : `${minutes}m`;
            } else if (interval < 30) {
                return `${Math.round(interval)}d`;
            } else if (interval < 365) {
                return `${Math.round(interval / 30)}mo`;
            } else {
                return `${(interval / 365).toFixed(1)}y`;
            }
        };
        
        // ============================================
        // 2. DATABASE (IndexedDB Wrapper)
        // ============================================
        
        class Database {
            constructor() {
                this.name = 'AnkiProDB_v3';
                this.version = 3;
                this.db = null;
                this.initPromise = null;
            }
            
            async init() {
                if (this.db) return this.db;
                if (this.initPromise) return this.initPromise;
                
                this.initPromise = new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.name, this.version);
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        // Create object stores if they don't exist
                        if (!db.objectStoreNames.contains('decks')) {
                            db.createObjectStore('decks', { keyPath: 'id' });
                        }
                        
                        if (!db.objectStoreNames.contains('cards')) {
                            const cardStore = db.createObjectStore('cards', { keyPath: 'id' });
                            cardStore.createIndex('deckId', 'deckId', { unique: false });
                            cardStore.createIndex('due', 'due', { unique: false });
                            cardStore.createIndex('created', 'created', { unique: false });
                        }
                        
                        if (!db.objectStoreNames.contains('reviews')) {
                            const reviewStore = db.createObjectStore('reviews', { keyPath: 'id' });
                            reviewStore.createIndex('cardId', 'cardId', { unique: false });
                            reviewStore.createIndex('timestamp', 'timestamp', { unique: false });
                            reviewStore.createIndex('date', 'date', { unique: false });
                        }
                        
                        if (!db.objectStoreNames.contains('settings')) {
                            db.createObjectStore('settings', { keyPath: 'key' });
                        }
                    };
                    
                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        
                        // Handle connection errors
                        this.db.onerror = (event) => {
                            console.error('Database error:', event.target.error);
                        };
                        
                        resolve(this.db);
                    };
                    
                    request.onerror = (event) => {
                        console.error('Database open error:', event.target.error);
                        reject(event.target.error);
                    };
                });
                
                return this.initPromise;
            }
            
            async withStore(storeNames, mode = 'readonly', callback) {
                try {
                    await this.init();
                    
                    const names = Array.isArray(storeNames) ? storeNames : [storeNames];
                    const transaction = this.db.transaction(names, mode);
                    
                    if (names.length === 1) {
                        const store = transaction.objectStore(names[0]);
                        return await callback(store, transaction);
                    } else {
                        const stores = {};
                        names.forEach(name => {
                            stores[name] = transaction.objectStore(name);
                        });
                        return await callback(stores, transaction);
                    }
                } catch (error) {
                    console.error(`Database operation failed for ${storeNames}:`, error);
                    throw error;
                }
            }
            
            // ===== DECK OPERATIONS =====
            
            async getDecks() {
                return this.withStore('decks', 'readonly', async (store) => {
                    return new Promise((resolve) => {
                        const request = store.getAll();
                        request.onsuccess = () => {
                            const decks = request.result || [];
                            // Sort by name
                            decks.sort((a, b) => a.name.localeCompare(b.name));
                            resolve(decks);
                        };
                        request.onerror = () => resolve([]);
                    });
                });
            }
            
            async getDeckById(id) {
                return this.withStore('decks', 'readonly', async (store) => {
                    return new Promise((resolve) => {
                        const request = store.get(id);
                        request.onsuccess = () => resolve(request.result || null);
                        request.onerror = () => resolve(null);
                    });
                });
            }
            
            async addDeck(name) {
                if (!name || name.trim().length === 0) {
                    throw new Error('Deck name cannot be empty');
                }
                
                const deck = {
                    id: generateId(),
                    name: name.trim(),
                    created: Date.now(),
                    updated: Date.now()
                };
                
                await this.withStore('decks', 'readwrite', async (store) => {
                    return new Promise((resolve, reject) => {
                        const request = store.add(deck);
                        request.onsuccess = () => resolve(deck);
                        request.onerror = () => reject(request.error);
                    });
                });
                
                return deck;
            }
            
            async updateDeck(deck) {
                await this.withStore('decks', 'readwrite', async (store) => {
                    return new Promise((resolve, reject) => {
                        deck.updated = Date.now();
                        const request = store.put(deck);
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });
                });
            }
            
            async deleteDeck(deckId) {
                // First get all cards in this deck
                const cards = await this.getCardsByDeck(deckId);
                
                // Delete deck and all its cards
                await this.withStore(['decks', 'cards'], 'readwrite', async (stores) => {
                    return new Promise((resolve) => {
                        stores.decks.delete(deckId);
                        cards.forEach(card => stores.cards.delete(card.id));
                        resolve();
                    });
                });
            }
            
            // ===== CARD OPERATIONS =====
            
            async addCard(card) {
                if (!card.deckId) {
                    throw new Error('Card must belong to a deck');
                }
                
                if (!card.front || card.front.trim().length === 0) {
                    throw new Error('Card front cannot be empty');
                }
                
                const newCard = {
                    id: generateId(),
                    created: Date.now(),
                    due: Date.now(), // Due immediately
                    interval: 0,
                    ease: 250, // 250%
                    reps: 0,
                    lapses: 0,
                    phase: 'learning', // learning, review, relearning
                    type: 'basic',
                    front: card.front.trim(),
                    back: (card.back || '').trim(),
                    ...card,
                    // Ensure these are not overwritten
                    id: generateId(),
                    created: Date.now(),
                };
                
                await this.withStore('cards', 'readwrite', async (store) => {
                    return new Promise((resolve, reject) => {
                        const request = store.add(newCard);
                        request.onsuccess = () => resolve(newCard);
                        request.onerror = () => reject(request.error);
                    });
                });
                
                return newCard;
            }
            
            async updateCard(card) {
                await this.withStore('cards', 'readwrite', async (store) => {
                    return new Promise((resolve, reject) => {
                        card.updated = Date.now();
                        const request = store.put(card);
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });
                });
            }
            
            async deleteCard(cardId) {
                await this.withStore('cards', 'readwrite', async (store) => {
                    return new Promise((resolve) => {
                        store.delete(cardId);
                        resolve();
                    });
                });
            }
            
            async getCardById(id) {
                return this.withStore('cards', 'readonly', async (store) => {
                    return new Promise((resolve) => {
                        const request = store.get(id);
                        request.onsuccess = () => resolve(request.result || null);
                        request.onerror = () => resolve(null);
                    });
                });
            }
            
            async getCardsByDeck(deckId) {
                return this.withStore('cards', 'readonly', async (store) => {
                    return new Promise((resolve) => {
                        const index = store.index('deckId');
                        const request = index.getAll(deckId);
                        request.onsuccess = () => resolve(request.result || []);
                        request.onerror = () => resolve([]);
                    });
                });
            }
            
            async getDueCards(deckId, limit = 100) {
                return this.withStore('cards', 'readonly', async (store) => {
                    return new Promise((resolve) => {
                        const index = store.index('deckId');
                        const range = IDBKeyRange.only(deckId);
                        const request = index.openCursor(range);
                        
                        const now = Date.now();
                        const dueCards = [];
                        
                        request.onsuccess = (event) => {
                            const cursor = event.target.result;
                            if (cursor && dueCards.length < limit) {
                                const card = cursor.value;
                                if (card.due <= now) {
                                    dueCards.push(card);
                                }
                                cursor.continue();
                            } else {
                                // Sort by due date (oldest first), then by phase (learning first)
                                dueCards.sort((a, b) => {
                                    if (a.phase === 'learning' && b.phase !== 'learning') return -1;
                                    if (a.phase !== 'learning' && b.phase === 'learning') return 1;
                                    return a.due - b.due;
                                });
                                resolve(dueCards);
                            }
                        };
                        request.onerror = () => resolve([]);
                    });
                });
            }
            
            async getNewCards(deckId, limit = 20) {
                return this.withStore('cards', 'readonly', async (store) => {
                    return new Promise((resolve) => {
                        const index = store.index('deckId');
                        const range = IDBKeyRange.only(deckId);
                        const request = index.openCursor(range);
                        
                        const newCards = [];
                        
                        request.onsuccess = (event) => {
                            const cursor = event.target.result;
                            if (cursor && newCards.length < limit) {
                                const card = cursor.value;
                                if (card.reps === 0 && card.phase === 'learning') {
                                    newCards.push(card);
                                }
                                cursor.continue();
                            } else {
                                newCards.sort((a, b) => a.created - b.created);
                                resolve(newCards);
                            }
                        };
                        request.onerror = () => resolve([]);
                    });
                });
            }
            
            // ===== STATISTICS =====
            
            async getDeckStats(deckId) {
                const cards = await this.getCardsByDeck(deckId);
                const now = Date.now();
                
                let newCount = 0;
                let learningCount = 0;
                let reviewCount = 0;
                let dueCount = 0;
                
                cards.forEach(card => {
                    if (card.reps === 0) {
                        newCount++;
                    } else if (card.phase === 'learning' || card.phase === 'relearning') {
                        learningCount++;
                    } else {
                        reviewCount++;
                    }
                    
                    if (card.due <= now) {
                        dueCount++;
                    }
                });
                
                return {
                    total: cards.length,
                    new: newCount,
                    learning: learningCount,
                    review: reviewCount,
                    due: dueCount
                };
            }
            
            async getStats() {
                const decks = await this.getDecks();
                let totalCards = 0;
                let totalDue = 0;
                let totalNew = 0;
                
                for (const deck of decks) {
                    const stats = await this.getDeckStats(deck.id);
                    totalCards += stats.total;
                    totalDue += stats.due;
                    totalNew += stats.new;
                }
                
                return {
                    decks: decks.length,
                    cards: totalCards,
                    due: totalDue,
                    new: totalNew
                };
            }
            
            // ===== REVIEW LOGGING =====
            
            async addReview(cardId, rating, responseTime) {
                const review = {
                    id: generateId(),
                    cardId: cardId,
                    rating: rating,
                    responseTime: responseTime,
                    timestamp: Date.now(),
                    date: new Date().toISOString().split('T')[0] // YYYY-MM-DD
                };
                
                await this.withStore('reviews', 'readwrite', async (store) => {
                    return new Promise((resolve) => {
                        store.add(review);
                        resolve();
                    });
                });
                
                return review;
            }
            
            async getTodayReviews() {
                const today = new Date().toISOString().split('T')[0];
                
                return this.withStore('reviews', 'readonly', async (store) => {
                    return new Promise((resolve) => {
                        const index = store.index('date');
                        const request = index.getAll(today);
                        request.onsuccess = () => resolve(request.result || []);
                        request.onerror = () => resolve([]);
                    });
                });
            }
            
            // ===== EXPORT/IMPORT =====
            
            async exportData() {
                const decks = await this.getDecks();
                const allCards = [];
                
                for (const deck of decks) {
                    const cards = await this.getCardsByDeck(deck.id);
                    allCards.push(...cards);
                }
                
                return {
                    version: 1,
                    exportDate: new Date().toISOString(),
                    decks: decks,
                    cards: allCards
                };
            }
            
            async importData(data) {
                if (!data || !data.decks || !data.cards) {
                    throw new Error('Invalid import data format');
                }
                
                // Import decks
                for (const deck of data.decks) {
                    await this.withStore('decks', 'readwrite', async (store) => {
                        return new Promise((resolve) => {
                            store.put(deck);
                            resolve();
                        });
                    });
                }
                
                // Import cards
                for (const card of data.cards) {
                    await this.withStore('cards', 'readwrite', async (store) => {
                        return new Promise((resolve) => {
                            store.put(card);
                            resolve();
                        });
                    });
                }
                
                return { decks: data.decks.length, cards: data.cards.length };
            }
            
            async clearAllData() {
                await Promise.all([
                    this.withStore('decks', 'readwrite', async (store) => store.clear()),
                    this.withStore('cards', 'readwrite', async (store) => store.clear()),
                    this.withStore('reviews', 'readwrite', async (store) => store.clear()),
                ]);
            }
        }
        
        // Create singleton database instance
        const db = new Database();
        
        // ============================================
        // 3. SCHEDULING ALGORITHM (SM-2 Enhanced)
        // ============================================
        
        const scheduler = (card, rating, now = Date.now()) => {
            // Validate inputs
            if (!card) throw new Error('Card is required');
            if (![1, 2, 3, 4].includes(rating)) throw new Error('Invalid rating');
            
            // Clone the card to avoid modifying the original
            const updatedCard = { ...card };
            
            const min = 60 * 1000; // 1 minute in milliseconds
            const hour = 60 * min;
            const day = 24 * hour;
            
            // Calculate next intervals based on rating and phase
            if (rating === 1) {
                // Again - reset progress
                updatedCard.lapses += 1;
                updatedCard.ease = Math.max(130, updatedCard.ease - 20);
                updatedCard.phase = 'relearning';
                updatedCard.interval = 0;
                updatedCard.due = now + min; // 1 minute
            } else if (updatedCard.phase === 'learning' || updatedCard.phase === 'relearning') {
                // Learning/Relearning phase
                if (rating === 2) {
                    // Hard - stay in learning
                    updatedCard.interval = 0;
                    updatedCard.due = now + 6 * min; // 6 minutes
                } else if (rating === 3) {
                    // Good - graduate or move forward
                    if (updatedCard.phase === 'relearning') {
                        updatedCard.phase = 'review';
                        updatedCard.interval = Math.max(1, Math.round(updatedCard.interval * 0.5));
                        updatedCard.due = now + updatedCard.interval * day;
                    } else {
                        updatedCard.phase = 'review';
                        updatedCard.interval = 1;
                        updatedCard.due = now + day;
                    }
                    updatedCard.reps = Math.max(1, updatedCard.reps + 1);
                } else if (rating === 4) {
                    // Easy - graduate with bonus
                    updatedCard.phase = 'review';
                    updatedCard.interval = 4;
                    updatedCard.ease += 15;
                    updatedCard.due = now + 4 * day;
                    updatedCard.reps = Math.max(1, updatedCard.reps + 1);
                }
            } else {
                // Review phase
                updatedCard.reps += 1;
                
                if (rating === 2) {
                    // Hard - shorter interval
                    updatedCard.interval = Math.max(1, Math.round(updatedCard.interval * 1.2));
                    updatedCard.ease = Math.max(130, updatedCard.ease - 15);
                } else if (rating === 3) {
                    // Good - standard growth
                    updatedCard.interval = Math.round(updatedCard.interval * (updatedCard.ease / 100));
                } else if (rating === 4) {
                    // Easy - bonus growth
                    updatedCard.interval = Math.round(updatedCard.interval * (updatedCard.ease / 100) * 1.3);
                    updatedCard.ease += 15;
                }
                
                // Apply interval
                updatedCard.interval = Math.max(1, updatedCard.interval);
                updatedCard.due = now + updatedCard.interval * day;
            }
            
            // Ensure ease stays within bounds
            updatedCard.ease = Math.max(130, Math.min(350, updatedCard.ease));
            updatedCard.lastReview = now;
            updatedCard.updated = now;
            
            return updatedCard;
        };
        
        // Get preview intervals for UI
        const getIntervalPreviews = (card) => {
            const previews = {};
            const now = Date.now();
            
            [1, 2, 3, 4].forEach(rating => {
                const updated = scheduler({ ...card }, rating, now);
                previews[rating] = formatInterval(updated.interval || (1 / (24 * 60))); // 1 minute minimum
            });
            
            return previews;
        };
        
        // ============================================
        // 4. REACT COMPONENTS
        // ============================================
        
        // ----- Theme Provider Component -----
        const ThemeProvider = ({ children }) => {
            const [isDark, setIsDark] = useState(() => {
                // Check localStorage first
                const saved = localStorage.getItem('theme');
                if (saved) return saved === 'dark';
                // Then check system preference
                return window.matchMedia('(prefers-color-scheme: dark)').matches;
            });
            
            useEffect(() => {
                // Apply dark mode class to body
                if (isDark) {
                    document.body.classList.add('dark');
                    document.documentElement.classList.add('dark');
                } else {
                    document.body.classList.remove('dark');
                    document.documentElement.classList.remove('dark');
                }
                // Save preference
                localStorage.setItem('theme', isDark ? 'dark' : 'light');
            }, [isDark]);
            
            // Watch for system preference changes
            useEffect(() => {
                const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
                const handleChange = (e) => {
                    const saved = localStorage.getItem('theme');
                    if (!saved) {
                        setIsDark(e.matches);
                    }
                };
                mediaQuery.addEventListener('change', handleChange);
                return () => mediaQuery.removeEventListener('change', handleChange);
            }, []);
            
            const toggleTheme = useCallback(() => {
                setIsDark(prev => !prev);
            }, []);
            
            return (
                <ThemeContext.Provider value={{ isDark, toggleTheme }}>
                    {children}
                </ThemeContext.Provider>
            );
        };
        
        // ----- Header Component -----
        const Header = ({ title, left = null, right = null, onBack = null }) => {
            const { isDark } = useContext(ThemeContext);
            
            return (
                <div className={`h-14 w-full flex items-center justify-between px-4 sticky top-0 z-50 transition-colors safe-area-top ${
                    isDark 
                        ? 'bg-black/90 backdrop-blur-xl border-b border-ios-darkSeparator' 
                        : 'bg-ios-bg/90 backdrop-blur-xl border-b border-ios-separator'
                }`}>
                    <div className="w-20 flex items-center">
                        {onBack ? (
                            <button
                                onClick={onBack}
                                className={`h-10 px-2 rounded-lg flex items-center gap-1 transition-colors ${
                                    isDark ? 'active:bg-gray-800' : 'active:bg-gray-200'
                                }`}
                                aria-label="Back"
                            >
                                <i className="fas fa-chevron-left text-ios-blue"></i>
                                <span className="text-ios-blue font-medium">Back</span>
                            </button>
                        ) : left}
                    </div>
                    <h1 className="font-semibold text-lg truncate max-w-[50%] text-center">{title}</h1>
                    <div className="w-20 flex justify-end items-center">
                        {right}
                    </div>
                </div>
            );
        };
        
        // ----- Tab Bar Component -----
        const TabBar = ({ activeTab, onTabChange }) => {
            const { isDark } = useContext(ThemeContext);
            
            const tabs = [
                { id: 'decks', icon: 'fa-layer-group', label: 'Decks' },
                { id: 'add', icon: 'fa-plus-circle', label: 'Add' },
                { id: 'stats', icon: 'fa-chart-bar', label: 'Stats' }
            ];
            
            return (
                <div className={`w-full flex justify-around items-start pt-2 pb-6 border-t transition-colors safe-area-bottom ${
                    isDark 
                        ? 'bg-ios-darkCard/95 backdrop-blur-xl border-ios-darkSeparator' 
                        : 'bg-ios-bg/95 backdrop-blur-xl border-ios-separator'
                }`}>
                    {tabs.map(tab => (
                        <button
                            key={tab.id}
                            onClick={() => onTabChange(tab.id)}
                            className={`flex flex-col items-center gap-1 w-20 py-1 transition-all duration-200 ${
                                activeTab === tab.id ? 'text-ios-blue' : 'text-ios-gray'
                            }`}
                            aria-label={tab.label}
                        >
                            <i className={`fas ${tab.icon} text-xl ${activeTab === tab.id ? 'scale-110' : ''}`}></i>
                            <span className="text-xs font-medium">{tab.label}</span>
                        </button>
                    ))}
                </div>
            );
        };
        
        // ----- Toast Notification Component -----
        const Toast = ({ message, type = 'info', duration = 3000, onClose }) => {
            const [visible, setVisible] = useState(true);
            
            useEffect(() => {
                const timer = setTimeout(() => {
                    setVisible(false);
                    setTimeout(onClose, 300);
                }, duration);
                return () => clearTimeout(timer);
            }, [duration, onClose]);
            
            if (!visible) return null;
            
            const styles = {
                success: { bg: 'bg-ios-green', icon: 'fa-check-circle' },
                error: { bg: 'bg-ios-red', icon: 'fa-exclamation-circle' },
                warning: { bg: 'bg-ios-orange', icon: 'fa-exclamation-triangle' },
                info: { bg: 'bg-ios-blue', icon: 'fa-info-circle' }
            };
            
            const style = styles[type] || styles.info;
            
            return (
                <div className={`fixed bottom-28 left-1/2 transform -translate-x-1/2 px-5 py-3 rounded-xl shadow-xl z-50 flex items-center gap-3 transition-all duration-300 animate-slide-up ${style.bg} text-white max-w-[90%]`}>
                    <i className={`fas ${style.icon} text-lg`}></i>
                    <span className="font-medium text-sm">{message}</span>
                </div>
            );
        };
        
        // ----- Empty State Component -----
        const EmptyState = ({ icon, title, message, action }) => {
            const { isDark } = useContext(ThemeContext);
            
            return (
                <div className="flex flex-col items-center justify-center p-8 text-center h-full animate-fade-in">
                    <div className={`w-20 h-20 rounded-full flex items-center justify-center mb-6 ${
                        isDark ? 'bg-gray-800' : 'bg-gray-100'
                    }`}>
                        <i className={`${icon} text-4xl ${isDark ? 'text-gray-400' : 'text-ios-gray'}`}></i>
                    </div>
                    <h2 className="text-2xl font-bold mb-3">{title}</h2>
                    <p className={`mb-8 max-w-xs ${isDark ? 'text-gray-400' : 'text-ios-gray'}`}>{message}</p>
                    {action}
                </div>
            );
        };
        
        // ----- Cloze Text Component -----
        const ClozeText = ({ text, clozeId, isRevealed = false }) => {
            const { isDark } = useContext(ThemeContext);
            
            // Parse cloze deletions safely
            const parseCloze = (inputText) => {
                if (!inputText) return [{ type: 'text', content: '' }];
                
                // Handle: {{c1::text}} and {{c1::text::hint}}
                const regex = /\{\{c(\d+)::([^}:]+)(?:::([^}]+))?\}\}/g;
                let lastIndex = 0;
                let match;
                const parts = [];
                
                while ((match = regex.exec(inputText)) !== null) {
                    // Add text before the match
                    if (match.index > lastIndex) {
                        parts.push({
                            type: 'text',
                            content: inputText.substring(lastIndex, match.index)
                        });
                    }
                    
                    const id = match[1];
                    const content = match[2];
                    const hint = match[3];
                    
                    parts.push({
                        type: 'cloze',
                        id: id,
                        content: content,
                        hint: hint
                    });
                    
                    lastIndex = regex.lastIndex;
                }
                
                // Add remaining text
                if (lastIndex < inputText.length) {
                    parts.push({
                        type: 'text',
                        content: inputText.substring(lastIndex)
                    });
                }
                
                return parts.length > 0 ? parts : [{ type: 'text', content: inputText }];
            };
            
            const parts = parseCloze(text);
            
            return (
                <span className="card-content">
                    {parts.map((part, index) => {
                        if (part.type === 'text') {
                            return (
                                <span
                                    key={index}
                                    dangerouslySetInnerHTML={{ __html: sanitize(part.content) }}
                                />
                            );
                        }
                        
                        if (part.type === 'cloze') {
                            const isTargetCloze = part.id === clozeId;
                            
                            if (isTargetCloze) {
                                if (isRevealed) {
                                    return (
                                        <span key={index} className="cloze-revealed">
                                            {part.content}
                                        </span>
                                    );
                                } else {
                                    return (
                                        <span
                                            key={index}
                                            className="cloze-hidden"
                                            title={part.hint || 'Click to reveal'}
                                        >
                                            {part.content}
                                        </span>
                                    );
                                }
                            } else {
                                // Non-target clozes show content normally
                                return (
                                    <span key={index} dangerouslySetInnerHTML={{ __html: sanitize(part.content) }} />
                                );
                            }
                        }
                        
                        return null;
                    })}
                </span>
            );
        };
        
        // ----- Study Card Component -----
        const StudyCard = ({ card, flipped, onFlip, isCloze = false, clozeId = null }) => {
            const { isDark } = useContext(ThemeContext);
            
            const renderFront = () => {
                if (isCloze && card.front && clozeId) {
                    return <ClozeText text={card.front} clozeId={clozeId} isRevealed={false} />;
                }
                return <div className="card-content" dangerouslySetInnerHTML={{ __html: sanitize(card.front) }} />;
            };
            
            const renderBack = () => {
                if (isCloze && card.front && clozeId) {
                    return (
                        <div className="w-full h-full flex flex-col">
                            <div className={`w-full pb-4 mb-4 border-b ${isDark ? 'border-ios-darkSeparator' : 'border-ios-separator'}`}>
                                <ClozeText text={card.front} clozeId={clozeId} isRevealed={true} />
                            </div>
                            {card.back && (
                                <div className={`flex-1 text-base ${isDark ? 'text-gray-400' : 'text-ios-gray'}`}>
                                    <div className="card-content" dangerouslySetInnerHTML={{ __html: sanitize(card.back) }} />
                                </div>
                            )}
                        </div>
                    );
                }
                
                return (
                    <div className="w-full h-full flex flex-col">
                        <div className={`w-full pb-4 mb-4 border-b ${isDark ? 'border-ios-darkSeparator' : 'border-ios-separator'}`}>
                            <div className="card-content text-lg" dangerouslySetInnerHTML={{ __html: sanitize(card.front) }} />
                        </div>
                        <div className="flex-1 flex items-center justify-center">
                            <div className="card-content text-2xl font-medium" dangerouslySetInnerHTML={{ __html: sanitize(card.back) }} />
                        </div>
                    </div>
                );
            };
            
            return (
                <div className="card-container w-full h-full max-h-[calc(100vh-220px)]">
                    <div className={`card-inner ${flipped ? 'card-flipped' : ''}`}>
                        {/* Front Face */}
                        <div
                            className={`card-face rounded-3xl shadow-lg cursor-pointer border ${
                                isDark 
                                    ? 'bg-ios-darkCard border-ios-darkSeparator' 
                                    : 'bg-ios-card border-ios-separator'
                            } ${flipped ? 'pointer-events-none' : ''}`}
                            onClick={onFlip}
                        >
                            <div className="text-2xl md:text-3xl font-medium leading-relaxed max-w-full break-words text-center">
                                {renderFront()}
                            </div>
                            <div className={`mt-8 text-sm uppercase font-bold tracking-widest ${
                                isDark ? 'text-gray-500' : 'text-ios-gray'
                            }`}>
                                Tap to show answer
                            </div>
                        </div>
                        
                        {/* Back Face */}
                        <div className={`card-face card-back rounded-3xl shadow-lg border ${
                            isDark 
                                ? 'bg-ios-darkCard border-ios-darkSeparator' 
                                : 'bg-ios-card border-ios-separator'
                        }`}>
                            <div className="text-xl md:text-2xl font-medium leading-relaxed max-w-full break-words text-center h-full w-full">
                                {renderBack()}
                            </div>
                        </div>
                    </div>
                </div>
            );
        };
        
        // ----- Study Controls Component -----
        const StudyControls = ({ flipped, onRate, card }) => {
            const { isDark } = useContext(ThemeContext);
            const intervals = useMemo(() => card ? getIntervalPreviews(card) : {}, [card]);
            
            if (!flipped) {
                return (
                    <button
                        onClick={() => onRate('flip')}
                        className="w-full bg-ios-blue text-white h-14 rounded-2xl font-bold text-lg shadow-lg active:scale-[0.98] transition-transform"
                    >
                        Show Answer
                    </button>
                );
            }
            
            const buttons = [
                { rating: 1, label: 'Again', color: 'ios-red', interval: intervals[1] || '1m' },
                { rating: 2, label: 'Hard', color: 'ios-orange', interval: intervals[2] || '6m' },
                { rating: 3, label: 'Good', color: 'ios-green', interval: intervals[3] || '1d' },
                { rating: 4, label: 'Easy', color: 'ios-blue', interval: intervals[4] || '4d' }
            ];
            
            return (
                <div className="grid grid-cols-4 gap-2 w-full">
                    {buttons.map(btn => (
                        <button
                            key={btn.rating}
                            onClick={() => onRate(btn.rating)}
                            className={`rating-btn flex flex-col items-center justify-center h-16 rounded-2xl transition-all ${
                                isDark 
                                    ? `bg-${btn.color}/20 hover:bg-${btn.color}/30` 
                                    : `bg-${btn.color}/10 hover:bg-${btn.color}/20`
                            }`}
                        >
                            <span className={`text-${btn.color} font-bold text-sm`}>{btn.label}</span>
                            <span className={`text-[10px] mt-1 ${isDark ? 'text-gray-400' : 'text-ios-gray'}`}>
                                {btn.interval}
                            </span>
                        </button>
                    ))}
                </div>
            );
        };
        
        // ============================================
        // MAIN VIEWS
        // ============================================
        
        // ----- Decks View -----
        const DecksView = ({ onSelectDeck, onCreateDeck }) => {
            const { isDark, toggleTheme } = useContext(ThemeContext);
            const [decks, setDecks] = useState([]);
            const [deckStats, setDeckStats] = useState({});
            const [loading, setLoading] = useState(true);
            const [showAddModal, setShowAddModal] = useState(false);
            const [deckName, setDeckName] = useState('');
            const [editingDeck, setEditingDeck] = useState(null);
            const [toast, setToast] = useState(null);
            
            // Load decks and their stats
            const loadDecks = useCallback(async () => {
                try {
                    setLoading(true);
                    const data = await db.getDecks();
                    setDecks(data);
                    
                    // Load stats for each deck
                    const stats = {};
                    for (const deck of data) {
                        stats[deck.id] = await db.getDeckStats(deck.id);
                    }
                    setDeckStats(stats);
                } catch (error) {
                    console.error('Error loading decks:', error);
                    setToast({ id: Date.now(), message: 'Failed to load decks', type: 'error' });
                } finally {
                    setLoading(false);
                }
            }, []);
            
            useEffect(() => {
                loadDecks();
            }, [loadDecks]);
            
            const handleCreateDeck = async () => {
                if (!deckName.trim()) {
                    setToast({ id: Date.now(), message: 'Please enter a deck name', type: 'warning' });
                    return;
                }
                
                try {
                    if (editingDeck) {
                        await db.updateDeck({ ...editingDeck, name: deckName.trim() });
                        setToast({ id: Date.now(), message: 'Deck updated!', type: 'success' });
                    } else {
                        await db.addDeck(deckName.trim());
                        setToast({ id: Date.now(), message: 'Deck created!', type: 'success' });
                    }
                    setDeckName('');
                    setEditingDeck(null);
                    setShowAddModal(false);
                    loadDecks();
                } catch (error) {
                    console.error('Error saving deck:', error);
                    setToast({ id: Date.now(), message: 'Failed to save deck', type: 'error' });
                }
            };
            
            const handleDeleteDeck = async (deckId, deckName) => {
                if (!window.confirm(`Delete "${deckName}" and all its cards? This cannot be undone.`)) {
                    return;
                }
                
                try {
                    await db.deleteDeck(deckId);
                    setToast({ id: Date.now(), message: 'Deck deleted', type: 'success' });
                    loadDecks();
                } catch (error) {
                    console.error('Error deleting deck:', error);
                    setToast({ id: Date.now(), message: 'Failed to delete deck', type: 'error' });
                }
            };
            
            const handleEditDeck = (deck, e) => {
                e.stopPropagation();
                setEditingDeck(deck);
                setDeckName(deck.name);
                setShowAddModal(true);
            };
            
            return (
                <div className="flex flex-col h-full">
                    <Header
                        title="Decks"
                        left={
                            <button
                                onClick={toggleTheme}
                                className={`w-10 h-10 rounded-full flex items-center justify-center transition-colors ${
                                    isDark ? 'hover:bg-gray-800' : 'hover:bg-gray-200'
                                }`}
                                aria-label="Toggle theme"
                            >
                                <i className={`fas ${isDark ? 'fa-sun text-yellow-400' : 'fa-moon text-ios-gray'} text-lg`}></i>
                            </button>
                        }
                        right={
                            <button
                                onClick={() => { setEditingDeck(null); setDeckName(''); setShowAddModal(true); }}
                                className="text-ios-blue text-xl active:opacity-50 transition-opacity"
                                aria-label="Add Deck"
                            >
                                <i className="fas fa-plus"></i>
                            </button>
                        }
                    />
                    
                    <div className="flex-1 overflow-y-auto p-4 pb-24">
                        {loading ? (
                            <div className="flex justify-center mt-10">
                                <div className="loader"></div>
                            </div>
                        ) : decks.length === 0 ? (
                            <EmptyState
                                icon="fas fa-folder-open"
                                title="No Decks Yet"
                                message="Create your first deck to start learning with spaced repetition"
                                action={
                                    <button
                                        onClick={() => setShowAddModal(true)}
                                        className="px-8 py-4 bg-ios-blue text-white rounded-2xl font-semibold shadow-lg hover:bg-opacity-90 transition-colors"
                                    >
                                        <i className="fas fa-plus mr-2"></i>
                                        Create Deck
                                    </button>
                                }
                            />
                        ) : (
                            <div className="space-y-3">
                                {decks.map(deck => {
                                    const stats = deckStats[deck.id] || { total: 0, due: 0, new: 0 };
                                    return (
                                        <div
                                            key={deck.id}
                                            onClick={() => onSelectDeck(deck)}
                                            className={`deck-card flex items-center justify-between p-4 rounded-2xl shadow-sm cursor-pointer ${
                                                isDark 
                                                    ? 'bg-ios-darkCard border border-ios-darkSeparator' 
                                                    : 'bg-ios-card'
                                            }`}
                                        >
                                            <div className="flex items-center gap-4 flex-1 min-w-0">
                                                <div className={`w-12 h-12 rounded-xl flex items-center justify-center flex-shrink-0 ${
                                                    isDark ? 'bg-ios-blue/20' : 'bg-ios-blue/10'
                                                }`}>
                                                    <i className="fas fa-book text-ios-blue text-xl"></i>
                                                </div>
                                                <div className="min-w-0 flex-1">
                                                    <h3 className="font-semibold text-lg truncate">{deck.name}</h3>
                                                    <div className={`text-sm flex items-center gap-3 ${isDark ? 'text-gray-400' : 'text-ios-gray'}`}>
                                                        <span>{stats.total} cards</span>
                                                        {stats.due > 0 && (
                                                            <span className="text-ios-blue font-medium">{stats.due} due</span>
                                                        )}
                                                        {stats.new > 0 && (
                                                            <span className="text-ios-green font-medium">{stats.new} new</span>
                                                        )}
                                                    </div>
                                                </div>
                                            </div>
                                            <div className="flex items-center gap-2">
                                                <button
                                                    onClick={(e) => handleEditDeck(deck, e)}
                                                    className={`w-8 h-8 rounded-full flex items-center justify-center transition-colors ${
                                                        isDark 
                                                            ? 'text-gray-400 hover:text-ios-blue hover:bg-gray-800' 
                                                            : 'text-ios-gray2 hover:text-ios-blue hover:bg-gray-100'
                                                    }`}
                                                    aria-label={`Edit ${deck.name}`}
                                                >
                                                    <i className="fas fa-pen text-sm"></i>
                                                </button>
                                                <button
                                                    onClick={(e) => { e.stopPropagation(); handleDeleteDeck(deck.id, deck.name); }}
                                                    className={`w-8 h-8 rounded-full flex items-center justify-center transition-colors ${
                                                        isDark 
                                                            ? 'text-gray-400 hover:text-ios-red hover:bg-gray-800' 
                                                            : 'text-ios-gray2 hover:text-ios-red hover:bg-gray-100'
                                                    }`}
                                                    aria-label={`Delete ${deck.name}`}
                                                >
                                                    <i className="fas fa-trash-alt text-sm"></i>
                                                </button>
                                                <i className={`fas fa-chevron-right ml-2 ${isDark ? 'text-gray-600' : 'text-ios-gray2'}`}></i>
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        )}
                        
                        <div className="mt-8 text-center opacity-50">
                            <p className="text-xs font-medium">Made with  by Muhammad Daler</p>
                        </div>
                    </div>
                    
                    {/* Add/Edit Deck Modal */}
                    {showAddModal && (
                        <div
                            className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4 backdrop-blur-sm animate-fade-in"
                            onClick={() => { setShowAddModal(false); setEditingDeck(null); setDeckName(''); }}
                        >
                            <div
                                className={`w-full max-w-md rounded-2xl p-6 shadow-xl transform transition-all animate-slide-up ${
                                    isDark ? 'bg-ios-darkCard border border-ios-darkSeparator' : 'bg-ios-card'
                                }`}
                                onClick={e => e.stopPropagation()}
                            >
                                <h3 className="text-xl font-bold mb-4 text-center">
                                    {editingDeck ? 'Edit Deck' : 'Create New Deck'}
                                </h3>
                                <input
                                    type="text"
                                    value={deckName}
                                    onChange={e => setDeckName(e.target.value)}
                                    placeholder="e.g., English Vocabulary"
                                    className={`w-full p-4 rounded-xl text-lg outline-none focus:ring-2 focus:ring-ios-blue transition-colors ${
                                        isDark 
                                            ? 'bg-gray-800 text-white border border-ios-darkSeparator' 
                                            : 'bg-ios-bg text-black'
                                    }`}
                                    autoFocus
                                    onKeyPress={e => e.key === 'Enter' && handleCreateDeck()}
                                />
                                <div className="flex gap-4 mt-6">
                                    <button
                                        onClick={() => { setShowAddModal(false); setEditingDeck(null); setDeckName(''); }}
                                        className={`flex-1 py-3 rounded-xl font-semibold transition-colors ${
                                            isDark 
                                                ? 'bg-gray-800 text-white hover:bg-gray-700' 
                                                : 'bg-ios-bg text-ios-blue hover:bg-gray-100'
                                        }`}
                                    >
                                        Cancel
                                    </button>
                                    <button
                                        onClick={handleCreateDeck}
                                        className="flex-1 py-3 bg-ios-blue text-white rounded-xl font-semibold shadow-md hover:bg-opacity-90 transition-colors"
                                    >
                                        {editingDeck ? 'Save' : 'Create'}
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}
                    
                    {/* Toast */}
                    {toast && (
                        <Toast
                            key={toast.id}
                            message={toast.message}
                            type={toast.type}
                            onClose={() => setToast(null)}
                        />
                    )}
                </div>
            );
        };
        
        // ----- Add Card View -----
        const AddCardView = ({ onCardAdded }) => {
            const { isDark } = useContext(ThemeContext);
            const [decks, setDecks] = useState([]);
            const [selectedDeckId, setSelectedDeckId] = useState('');
            const [cardType, setCardType] = useState('basic');
            const [frontText, setFrontText] = useState('');
            const [backText, setBackText] = useState('');
            const [isProcessing, setIsProcessing] = useState(false);
            const [toast, setToast] = useState(null);
            const frontTextAreaRef = useRef(null);
            
            useEffect(() => {
                const loadDecks = async () => {
                    try {
                        const data = await db.getDecks();
                        setDecks(data);
                        if (data.length > 0 && !selectedDeckId) {
                            setSelectedDeckId(data[0].id);
                        }
                    } catch (error) {
                        console.error('Error loading decks:', error);
                    }
                };
                loadDecks();
            }, []);
            
            const insertCloze = () => {
                const textarea = frontTextAreaRef.current;
                if (!textarea) return;
                
                const start = textarea.selectionStart;
                const end = textarea.selectionEnd;
                const selectedText = frontText.substring(start, end) || 'text';
                
                // Find the highest cloze ID used
                let maxClozeId = 0;
                const clozeRegex = /\{\{c(\d+)::/g;
                let match;
                while ((match = clozeRegex.exec(frontText)) !== null) {
                    const id = parseInt(match[1]);
                    if (id > maxClozeId) maxClozeId = id;
                }
                
                const nextClozeId = maxClozeId + 1;
                const clozeText = `{{c${nextClozeId}::${selectedText}}}`;
                
                const newText = frontText.substring(0, start) + clozeText + frontText.substring(end);
                setFrontText(newText);
                
                setTimeout(() => {
                    if (textarea) {
                        const newPosition = start + clozeText.length;
                        textarea.focus();
                        textarea.setSelectionRange(newPosition, newPosition);
                    }
                }, 0);
            };
            
            const handleSaveCard = async () => {
                if (!selectedDeckId) {
                    setToast({ id: Date.now(), message: 'Please select a deck', type: 'warning' });
                    return;
                }
                
                if (!frontText.trim()) {
                    setToast({ id: Date.now(), message: 'Front field cannot be empty', type: 'warning' });
                    return;
                }
                
                if (cardType === 'cloze') {
                    const hasCloze = /\{\{c\d+::.+?\}\}/g.test(frontText);
                    if (!hasCloze) {
                        setToast({ id: Date.now(), message: 'No cloze deletions found. Use [...] button to create one.', type: 'warning' });
                        return;
                    }
                }
                
                setIsProcessing(true);
                
                try {
                    let cardsCreated = 0;
                    
                    if (cardType === 'basic') {
                        await db.addCard({
                            deckId: selectedDeckId,
                            type: 'basic',
                            front: frontText.trim(),
                            back: backText.trim()
                        });
                        cardsCreated = 1;
                    } else {
                        // For cloze cards, find all unique cloze IDs
                        const clozeRegex = /\{\{c(\d+)::/g;
                        const matches = [...frontText.matchAll(clozeRegex)];
                        const uniqueClozeIds = [...new Set(matches.map(m => m[1]))];
                        
                        if (uniqueClozeIds.length === 0) {
                            throw new Error('No valid cloze deletions found');
                        }
                        
                        // Create a card for each unique cloze ID
                        for (const clozeId of uniqueClozeIds) {
                            await db.addCard({
                                deckId: selectedDeckId,
                                type: 'cloze',
                                front: frontText.trim(),
                                back: backText.trim(),
                                clozeId: clozeId
                            });
                            cardsCreated++;
                        }
                    }
                    
                    setToast({
                        id: Date.now(),
                        message: cardType === 'basic' 
                            ? 'Card added successfully!' 
                            : `${cardsCreated} cloze card(s) created!`,
                        type: 'success'
                    });
                    
                    setFrontText('');
                    setBackText('');
                    
                    if (onCardAdded) onCardAdded();
                } catch (error) {
                    console.error('Error adding card:', error);
                    setToast({ id: Date.now(), message: 'Failed to add card', type: 'error' });
                } finally {
                    setIsProcessing(false);
                }
            };
            
            return (
                <div className="flex flex-col h-full">
                    <Header title="Add Card" />
                    
                    <div className="flex-1 overflow-y-auto p-4 pb-24 space-y-4">
                        {/* Deck and Card Type Selection */}
                        <div className={`rounded-2xl p-4 shadow-sm ${
                            isDark ? 'bg-ios-darkCard border border-ios-darkSeparator' : 'bg-ios-card'
                        }`}>
                            <label className={`block text-xs font-bold uppercase tracking-wider mb-2 ${
                                isDark ? 'text-gray-400' : 'text-ios-gray'
                            }`}>
                                Target Deck
                            </label>
                            
                            {decks.length === 0 ? (
                                <p className={`text-sm ${isDark ? 'text-gray-400' : 'text-ios-gray'}`}>
                                    No decks available. Create a deck first.
                                </p>
                            ) : (
                                <select
                                    value={selectedDeckId}
                                    onChange={e => setSelectedDeckId(e.target.value)}
                                    className={`w-full p-3 rounded-xl text-lg outline-none focus:ring-2 focus:ring-ios-blue appearance-none transition-colors ${
                                        isDark 
                                            ? 'bg-gray-800 text-white border border-ios-darkSeparator' 
                                            : 'bg-ios-bg text-black'
                                    }`}
                                >
                                    {decks.map(deck => (
                                        <option key={deck.id} value={deck.id}>{deck.name}</option>
                                    ))}
                                </select>
                            )}
                            
                            <label className={`block text-xs font-bold uppercase tracking-wider mt-4 mb-2 ${
                                isDark ? 'text-gray-400' : 'text-ios-gray'
                            }`}>
                                Card Type
                            </label>
                            <div className={`flex p-1 rounded-xl overflow-hidden ${isDark ? 'bg-gray-800' : 'bg-ios-bg'}`}>
                                <button
                                    onClick={() => setCardType('basic')}
                                    className={`flex-1 py-3 text-sm font-semibold rounded-lg transition-all ${
                                        cardType === 'basic'
                                            ? (isDark ? 'bg-gray-700 text-white shadow-sm' : 'bg-white text-black shadow-sm')
                                            : (isDark ? 'text-gray-400' : 'text-ios-gray')
                                    }`}
                                >
                                    Basic
                                </button>
                                <button
                                    onClick={() => setCardType('cloze')}
                                    className={`flex-1 py-3 text-sm font-semibold rounded-lg transition-all ${
                                        cardType === 'cloze'
                                            ? (isDark ? 'bg-gray-700 text-white shadow-sm' : 'bg-white text-black shadow-sm')
                                            : (isDark ? 'text-gray-400' : 'text-ios-gray')
                                    }`}
                                >
                                    Cloze
                                </button>
                            </div>
                        </div>
                        
                        {/* Card Content */}
                        <div className={`rounded-2xl p-4 shadow-sm ${
                            isDark ? 'bg-ios-darkCard border border-ios-darkSeparator' : 'bg-ios-card'
                        }`}>
                            <div className="flex justify-between items-center mb-3">
                                <label className={`text-xs font-bold uppercase tracking-wider ${
                                    isDark ? 'text-gray-400' : 'text-ios-gray'
                                }`}>
                                    Front
                                </label>
                                {cardType === 'cloze' && (
                                    <button
                                        onClick={insertCloze}
                                        className="px-3 py-1 bg-ios-blue text-white text-xs font-bold rounded-full shadow-sm hover:bg-opacity-90 transition-colors active:scale-95"
                                        title="Insert Cloze Deletion"
                                    >
                                        <i className="fas fa-eye-slash mr-1"></i>
                                        [...]
                                    </button>
                                )}
                            </div>
                            
                            <textarea
                                ref={frontTextAreaRef}
                                value={frontText}
                                onChange={e => setFrontText(e.target.value)}
                                placeholder={cardType === 'cloze' 
                                    ? 'Type your text and select words to hide, then click [...]' 
                                    : 'Type your question here...'
                                }
                                className={`w-full min-h-[120px] p-3 rounded-xl text-lg outline-none focus:ring-2 focus:ring-ios-blue resize-none transition-colors ${
                                    isDark 
                                        ? 'bg-gray-800 text-white border border-ios-darkSeparator' 
                                        : 'bg-ios-bg text-black'
                                }`}
                            />
                            
                            <label className={`block text-xs font-bold uppercase tracking-wider mt-4 mb-2 ${
                                isDark ? 'text-gray-400' : 'text-ios-gray'
                            }`}>
                                Back {cardType === 'cloze' ? '(Optional - Extra Info)' : ''}
                            </label>
                            
                            <textarea
                                value={backText}
                                onChange={e => setBackText(e.target.value)}
                                placeholder="Additional information or answer..."
                                className={`w-full min-h-[80px] p-3 rounded-xl text-lg outline-none focus:ring-2 focus:ring-ios-blue resize-none transition-colors ${
                                    isDark 
                                        ? 'bg-gray-800 text-white border border-ios-darkSeparator' 
                                        : 'bg-ios-bg text-black'
                                }`}
                            />
                        </div>
                        
                        {/* Save Button */}
                        <button
                            onClick={handleSaveCard}
                            disabled={isProcessing || !selectedDeckId}
                            className={`w-full py-4 rounded-2xl font-bold text-lg shadow-md transition-all ${
                                isProcessing || !selectedDeckId
                                    ? 'bg-gray-400 cursor-not-allowed'
                                    : 'bg-ios-blue text-white active:scale-[0.98] hover:bg-opacity-90'
                            }`}
                        >
                            {isProcessing ? (
                                <div className="flex items-center justify-center">
                                    <div className="loader mr-2"></div>
                                    <span>Adding Card...</span>
                                </div>
                            ) : (
                                <>
                                    <i className="fas fa-plus mr-2"></i>
                                    Add to Deck
                                </>
                            )}
                        </button>
                        
                        {/* Cloze Example */}
                        {cardType === 'cloze' && (
                            <div className={`p-4 rounded-xl ${isDark ? 'bg-gray-800 border border-ios-darkSeparator' : 'bg-ios-bg'}`}>
                                <p className="font-medium mb-2">
                                    <i className="fas fa-lightbulb text-ios-yellow mr-2"></i>
                                    Cloze Example
                                </p>
                                <p className={`text-sm ${isDark ? 'text-gray-400' : 'text-ios-gray'}`}>
                                    Select text and click <code className="bg-black/10 dark:bg-white/10 px-1 rounded">[...]</code> to hide it.
                                    <br/><br/>
                                    Format: <code className="bg-black/10 dark:bg-white/10 px-1 rounded">{`{{c1::word}}`}</code>
                                    <br/>
                                    With hint: <code className="bg-black/10 dark:bg-white/10 px-1 rounded">{`{{c1::word::hint}}`}</code>
                                </p>
                            </div>
                        )}
                    </div>
                    
                    {/* Toast */}
                    {toast && (
                        <Toast
                            key={toast.id}
                            message={toast.message}
                            type={toast.type}
                            onClose={() => setToast(null)}
                        />
                    )}
                </div>
            );
        };
        
        // ----- Study View -----
        const StudyView = ({ deck, onBack }) => {
            const { isDark } = useContext(ThemeContext);
            const [cards, setCards] = useState([]);
            const [currentIndex, setCurrentIndex] = useState(0);
            const [flipped, setFlipped] = useState(false);
            const [loading, setLoading] = useState(true);
            const [sessionStats, setSessionStats] = useState({ correct: 0, total: 0, reviewed: 0 });
            const [toast, setToast] = useState(null);
            const [startTime, setStartTime] = useState(null);
            
            const loadCards = useCallback(async () => {
                try {
                    setLoading(true);
                    const dueCards = await db.getDueCards(deck.id);
                    setCards(dueCards);
                    setSessionStats({ correct: 0, total: dueCards.length, reviewed: 0 });
                    setCurrentIndex(0);
                    setFlipped(false);
                } catch (error) {
                    console.error('Error loading cards:', error);
                    setToast({ id: Date.now(), message: 'Failed to load cards', type: 'error' });
                } finally {
                    setLoading(false);
                }
            }, [deck.id]);
            
            useEffect(() => {
                loadCards();
            }, [loadCards]);
            
            useEffect(() => {
                if (!flipped) {
                    setStartTime(Date.now());
                }
            }, [currentIndex, flipped]);
            
            const handleRateCard = async (rating) => {
                if (rating === 'flip') {
                    setFlipped(true);
                    return;
                }
                
                if (currentIndex >= cards.length) return;
                
                const card = cards[currentIndex];
                const responseTime = startTime ? Date.now() - startTime : 0;
                
                try {
                    const updatedCard = scheduler(card, rating);
                    await db.updateCard(updatedCard);
                    await db.addReview(card.id, rating, responseTime);
                    
                    setSessionStats(prev => ({
                        ...prev,
                        correct: prev.correct + (rating >= 3 ? 1 : 0),
                        reviewed: prev.reviewed + 1
                    }));
                    
                    if (currentIndex < cards.length - 1) {
                        setCurrentIndex(prev => prev + 1);
                        setFlipped(false);
                    } else {
                        // Session complete
                        setToast({
                            id: Date.now(),
                            message: `Session complete! ${sessionStats.correct + (rating >= 3 ? 1 : 0)}/${sessionStats.total} correct`,
                            type: 'success',
                            duration: 5000
                        });
                        setCurrentIndex(cards.length); // Show completion screen
                    }
                } catch (error) {
                    console.error('Error updating card:', error);
                    setToast({ id: Date.now(), message: 'Failed to update card', type: 'error' });
                }
            };
            
            if (loading) {
                return (
                    <div className="h-full flex items-center justify-center">
                        <div className="loader"></div>
                    </div>
                );
            }
            
            if (cards.length === 0 || currentIndex >= cards.length) {
                return (
                    <div className="h-full flex flex-col">
                        <Header title={deck.name} onBack={onBack} />
                        <div className="flex-1 flex flex-col items-center justify-center p-6 text-center animate-bounce-in">
                            <div className={`w-24 h-24 rounded-full flex items-center justify-center mb-6 shadow-lg ${
                                isDark ? 'bg-ios-green/20' : 'bg-ios-green/10'
                            }`}>
                                <i className="fas fa-check text-5xl text-ios-green"></i>
                            </div>
                            <h2 className="text-3xl font-bold mb-3">
                                {cards.length === 0 ? 'No Cards Due' : 'Congratulations!'}
                            </h2>
                            <p className={`text-lg mb-3 ${isDark ? 'text-gray-300' : 'text-ios-gray'}`}>
                                {cards.length === 0 
                                    ? 'All caught up! Add more cards or check back later.'
                                    : 'You have completed this study session!'}
                            </p>
                            {sessionStats.reviewed > 0 && (
                                <div className={`mb-8 text-lg ${isDark ? 'text-gray-400' : 'text-ios-gray'}`}>
                                    <span className="text-ios-green font-bold">{sessionStats.correct}</span> / {sessionStats.reviewed} correct
                                    <span className="ml-2">
                                        ({Math.round((sessionStats.correct / sessionStats.reviewed) * 100)}%)
                                    </span>
                                </div>
                            )}
                            <button
                                onClick={onBack}
                                className={`px-8 py-4 rounded-2xl font-bold text-lg shadow-md transition-all ${
                                    isDark 
                                        ? 'bg-gray-800 text-white hover:bg-gray-700' 
                                        : 'bg-ios-card text-ios-blue hover:bg-gray-50'
                                }`}
                            >
                                <i className="fas fa-arrow-left mr-2"></i>
                                Return to Decks
                            </button>
                        </div>
                    </div>
                );
            }
            
            const currentCard = cards[currentIndex];
            const isCloze = currentCard.type === 'cloze';
            
            return (
                <div className="flex flex-col h-full">
                    <Header
                        title={`${currentIndex + 1} / ${cards.length}`}
                        onBack={onBack}
                        right={
                            <span className={`text-sm font-medium ${isDark ? 'text-gray-400' : 'text-ios-gray'}`}>
                                {deck.name}
                            </span>
                        }
                    />
                    
                    <div className="flex-1 flex items-center justify-center p-4">
                        <StudyCard
                            card={currentCard}
                            flipped={flipped}
                            onFlip={() => setFlipped(true)}
                            isCloze={isCloze}
                            clozeId={isCloze ? currentCard.clozeId : null}
                        />
                    </div>
                    
                    <div className={`p-4 border-t transition-colors ${
                        isDark 
                            ? 'bg-black/90 backdrop-blur-xl border-ios-darkSeparator' 
                            : 'bg-ios-bg/90 backdrop-blur-xl border-ios-separator'
                    }`}>
                        <StudyControls
                            flipped={flipped}
                            onRate={handleRateCard}
                            card={currentCard}
                        />
                        
                        {/* Progress bar */}
                        <div className="mt-4">
                            <div className={`h-1 w-full rounded-full overflow-hidden ${isDark ? 'bg-gray-800' : 'bg-gray-200'}`}>
                                <div
                                    className="h-full bg-ios-blue rounded-full transition-all duration-300"
                                    style={{ width: `${((currentIndex + 1) / cards.length) * 100}%` }}
                                ></div>
                            </div>
                        </div>
                    </div>
                    
                    {/* Toast */}
                    {toast && (
                        <Toast
                            key={toast.id}
                            message={toast.message}
                            type={toast.type}
                            duration={toast.duration}
                            onClose={() => setToast(null)}
                        />
                    )}
                </div>
            );
        };
        
        // ----- Stats View -----
        const StatsView = () => {
            const { isDark } = useContext(ThemeContext);
            const [stats, setStats] = useState({ decks: 0, cards: 0, due: 0, new: 0 });
            const [todayReviews, setTodayReviews] = useState([]);
            const [loading, setLoading] = useState(true);
            
            useEffect(() => {
                const loadStats = async () => {
                    try {
                        setLoading(true);
                        const data = await db.getStats();
                        setStats(data);
                        const reviews = await db.getTodayReviews();
                        setTodayReviews(reviews);
                    } catch (error) {
                        console.error('Error loading stats:', error);
                    } finally {
                        setLoading(false);
                    }
                };
                loadStats();
            }, []);
            
            const successRate = todayReviews.length > 0
                ? Math.round((todayReviews.filter(r => r.rating >= 3).length / todayReviews.length) * 100)
                : 0;
            
            const avgResponseTime = todayReviews.length > 0
                ? Math.round(todayReviews.reduce((acc, r) => acc + (r.responseTime || 0), 0) / todayReviews.length / 1000)
                : 0;
            
            return (
                <div className="flex flex-col h-full">
                    <Header title="Statistics" />
                    
                    {loading ? (
                        <div className="flex justify-center mt-10">
                            <div className="loader"></div>
                        </div>
                    ) : (
                        <div className="p-4 space-y-4 flex-1 overflow-y-auto pb-24">
                            {/* Summary Cards */}
                            <div className="grid grid-cols-2 gap-3">
                                <div className={`p-5 rounded-2xl shadow-sm flex flex-col items-center justify-center ${
                                    isDark ? 'bg-ios-darkCard border border-ios-darkSeparator' : 'bg-ios-card'
                                }`}>
                                    <div className="text-4xl font-bold text-ios-blue mb-2">{stats.decks}</div>
                                    <div className={`text-xs uppercase font-bold tracking-wider ${isDark ? 'text-gray-400' : 'text-ios-gray'}`}>
                                        Total Decks
                                    </div>
                                </div>
                                <div className={`p-5 rounded-2xl shadow-sm flex flex-col items-center justify-center ${
                                    isDark ? 'bg-ios-darkCard border border-ios-darkSeparator' : 'bg-ios-card'
                                }`}>
                                    <div className="text-4xl font-bold text-ios-green mb-2">{stats.cards}</div>
                                    <div className={`text-xs uppercase font-bold tracking-wider ${isDark ? 'text-gray-400' : 'text-ios-gray'}`}>
                                        Total Cards
                                    </div>
                                </div>
                            </div>
                            
                            {/* Due Cards */}
                            <div className={`p-5 rounded-2xl shadow-sm ${
                                isDark ? 'bg-ios-darkCard border border-ios-darkSeparator' : 'bg-ios-card'
                            }`}>
                                <div className="flex items-center justify-between mb-4">
                                    <h3 className="font-semibold text-lg">Cards Due Today</h3>
                                    <div className="text-3xl font-bold text-ios-orange">{stats.due}</div>
                                </div>
                                <div className={`h-3 w-full rounded-full overflow-hidden ${isDark ? 'bg-gray-800' : 'bg-ios-bg'}`}>
                                    <div
                                        className="h-full bg-ios-orange rounded-full transition-all duration-500"
                                        style={{ width: stats.cards > 0 ? `${(stats.due / stats.cards) * 100}%` : '0%' }}
                                    ></div>
                                </div>
                                <div className={`mt-2 text-sm ${isDark ? 'text-gray-400' : 'text-ios-gray'}`}>
                                    {stats.new} new cards available
                                </div>
                            </div>
                            
                            {/* Today's Session */}
                            <div className={`p-5 rounded-2xl shadow-sm ${
                                isDark ? 'bg-ios-darkCard border border-ios-darkSeparator' : 'bg-ios-card'
                            }`}>
                                <h3 className="font-semibold text-lg mb-4">
                                    <i className="fas fa-calendar-day text-ios-blue mr-2"></i>
                                    Today's Study
                                </h3>
                                <div className="space-y-3">
                                    <div className="flex justify-between items-center">
                                        <span className={isDark ? 'text-gray-400' : 'text-ios-gray'}>Cards Reviewed</span>
                                        <span className="font-bold text-lg">{todayReviews.length}</span>
                                    </div>
                                    <div className="flex justify-between items-center">
                                        <span className={isDark ? 'text-gray-400' : 'text-ios-gray'}>Success Rate</span>
                                        <span className={`font-bold text-lg ${successRate >= 70 ? 'text-ios-green' : successRate >= 50 ? 'text-ios-orange' : 'text-ios-red'}`}>
                                            {successRate}%
                                        </span>
                                    </div>
                                    <div className="flex justify-between items-center">
                                        <span className={isDark ? 'text-gray-400' : 'text-ios-gray'}>Avg. Response Time</span>
                                        <span className="font-bold text-lg">{avgResponseTime}s</span>
                                    </div>
                                </div>
                            </div>
                            
                            {/* App Info */}
                            <div className={`mt-6 p-5 rounded-2xl text-center ${
                                isDark ? 'bg-ios-darkCard border border-ios-darkSeparator' : 'bg-ios-card'
                            }`}>
                                <div className={`text-xs uppercase font-bold tracking-wider mb-2 ${isDark ? 'text-gray-400' : 'text-ios-gray'}`}>
                                    App Information
                                </div>
                                <div className="font-medium">Anki macOS Pro</div>
                                <div className={`text-sm mt-1 ${isDark ? 'text-gray-400' : 'text-ios-gray'}`}>
                                    Version 2.0.0
                                </div>
                                <div className={`text-xs mt-2 ${isDark ? 'text-gray-500' : 'text-ios-gray'}`}>
                                     2025 Muhammad Daler
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };
        
        // ============================================
        // MAIN APP
        // ============================================
        
        const App = () => {
            const [activeTab, setActiveTab] = useState('decks');
            const [selectedDeck, setSelectedDeck] = useState(null);
            
            // Initialize database on mount
            useEffect(() => {
                db.init().catch(console.error);
            }, []);
            
            const handleBackFromStudy = useCallback(() => {
                setSelectedDeck(null);
            }, []);
            
            const handleCardAdded = useCallback(() => {
                // Could refresh stats or other data here
            }, []);
            
            return (
                <ThemeProvider>
                    <div className="flex flex-col h-full">
                        {selectedDeck ? (
                            <StudyView
                                deck={selectedDeck}
                                onBack={handleBackFromStudy}
                            />
                        ) : (
                            <>
                                {activeTab === 'decks' && (
                                    <DecksView onSelectDeck={setSelectedDeck} />
                                )}
                                {activeTab === 'add' && (
                                    <AddCardView onCardAdded={handleCardAdded} />
                                )}
                                {activeTab === 'stats' && (
                                    <StatsView />
                                )}
                                <TabBar activeTab={activeTab} onTabChange={setActiveTab} />
                            </>
                        )}
                    </div>
                </ThemeProvider>
            );
        };
        
        // Render the app
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
