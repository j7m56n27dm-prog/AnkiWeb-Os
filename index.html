<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Anki iOS - Made by Muhammad Daler</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    
    <style>
        :root {
            --bg-primary: #000000;
            --bg-secondary: #1c1c1e;
            --text-primary: #ffffff;
            --text-secondary: #8e8e93;
            --accent: #0a84ff;
            --danger: #ff453a;
            --success: #32d74b;
            --warning: #ff9f0a;
            --card-bg: #2c2c2e;
            --separator: #38383a;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            height: 100vh;
            overflow: hidden;
            -webkit-tap-highlight-color: transparent;
        }

        /* View Container */
        .view-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 60px;
            background: rgba(28, 28, 30, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--separator);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
            z-index: 1000;
        }

        /* Tab Bar */
        .tab-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 60px;
            background: rgba(28, 28, 30, 0.95);
            backdrop-filter: blur(10px);
            border-top: 1px solid var(--separator);
            display: flex;
            justify-content: space-around;
            align-items: center;
            z-index: 1000;
        }

        .tab-item {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            font-size: 10px;
            gap: 4px;
            height: 100%;
            cursor: pointer;
            transition: color 0.2s;
        }

        .tab-item.active {
            color: var(--accent);
        }

        .tab-item i {
            font-size: 20px;
        }

        /* Views */
        .view {
            position: absolute;
            top: 60px;
            left: 0;
            width: 100%;
            height: calc(100% - 120px);
            overflow-y: auto;
            display: none;
            padding-bottom: 20px;
        }

        .view.active {
            display: block;
        }

        /* Deck List */
        .deck-list {
            padding: 16px;
        }

        .deck-item {
            background-color: var(--bg-secondary);
            padding: 16px;
            margin-bottom: 12px;
            border-radius: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.2s;
        }

        .deck-item:active {
            transform: scale(0.98);
            background-color: var(--card-bg);
        }

        .deck-counts {
            display: flex;
            gap: 12px;
        }

        .count-new { color: var(--accent); }
        .count-learn { color: var(--warning); }
        .count-review { color: var(--success); }

        /* Flashcard */
        .flashcard-container {
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .flashcard {
            background: var(--card-bg);
            border-radius: 16px;
            width: 100%;
            max-width: 600px;
            min-height: 300px;
            padding: 32px 24px;
            font-size: 20px;
            line-height: 1.5;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            cursor: pointer;
            user-select: none;
            overflow-wrap: break-word;
            word-break: break-word;
        }

        .card-content {
            width: 100%;
        }

        /* Review Controls */
        .review-controls {
            position: fixed;
            bottom: 70px;
            left: 0;
            width: 100%;
            padding: 0 16px;
            display: flex;
            gap: 8px;
            z-index: 900;
        }

        .btn-answer {
            flex: 1;
            padding: 12px 0;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
            color: white;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            border: none;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .btn-answer:active {
            opacity: 0.8;
        }

        .btn-again { background-color: var(--danger); }
        .btn-hard { background-color: var(--warning); }
        .btn-good { background-color: var(--success); }
        .btn-easy { background-color: var(--accent); }

        .btn-answer small {
            font-size: 10px;
            opacity: 0.9;
            font-weight: normal;
            margin-top: 2px;
        }

        /* Form Elements */
        .form-container {
            padding: 16px;
        }

        .form-group {
            margin-bottom: 16px;
        }

        .form-label {
            display: block;
            color: var(--text-secondary);
            font-size: 14px;
            margin-bottom: 6px;
        }

        .form-input,
        .form-textarea,
        .form-select {
            width: 100%;
            padding: 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--separator);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 16px;
            font-family: inherit;
        }

        .form-textarea {
            min-height: 100px;
            resize: vertical;
        }

        .form-button {
            width: 100%;
            padding: 14px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .form-button:active {
            opacity: 0.8;
        }

        /* Cloze Styles */
        .cloze {
            color: var(--accent);
            font-weight: bold;
            background: rgba(10, 132, 255, 0.1);
            padding: 2px 4px;
            border-radius: 4px;
        }

        .cloze-blank {
            color: var(--accent);
            font-weight: bold;
            border-bottom: 2px dashed var(--accent);
            padding: 0 4px;
            cursor: pointer;
        }

        /* Browser */
        .browser-list {
            padding: 16px;
        }

        .browser-item {
            background: var(--bg-secondary);
            padding: 16px;
            margin-bottom: 12px;
            border-radius: 12px;
            border-left: 4px solid var(--accent);
        }

        /* Stats */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
            padding: 16px;
        }

        .stat-card {
            background: var(--card-bg);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
        }

        .stat-value {
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 4px;
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-secondary);
        }

        /* FAB */
        .fab {
            position: fixed;
            bottom: 70px;
            right: 20px;
            width: 56px;
            height: 56px;
            border-radius: 28px;
            background: var(--accent);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
            z-index: 900;
            cursor: pointer;
            border: none;
            transition: transform 0.2s;
        }

        .fab:active {
            transform: scale(0.95);
        }

        /* Utility Classes */
        .hidden {
            display: none !important;
        }

        .loading {
            opacity: 0.5;
            pointer-events: none;
        }

        .error {
            color: var(--danger);
            background: rgba(255, 69, 58, 0.1);
            padding: 12px;
            border-radius: 8px;
            margin: 16px;
            text-align: center;
        }

        .success {
            color: var(--success);
            background: rgba(50, 215, 75, 0.1);
            padding: 12px;
            border-radius: 8px;
            margin: 16px;
            text-align: center;
        }

        /* Cloze Examples */
        .cloze-examples {
            background: var(--bg-secondary);
            padding: 16px;
            margin: 16px;
            border-radius: 12px;
            font-size: 14px;
            color: var(--text-secondary);
        }

        .cloze-examples h4 {
            color: var(--accent);
            margin-bottom: 8px;
        }

        .cloze-examples code {
            background: rgba(255,255,255,0.1);
            padding: 2px 4px;
            border-radius: 4px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <h1 id="header-title" class="text-lg font-bold">Anki iOS</h1>
        <div id="header-actions"></div>
    </div>

    <!-- View Container -->
    <div class="view-container">
        <!-- Deck List View -->
        <div id="view-decks" class="view active">
            <div class="deck-list">
                <h2 class="text-lg font-bold mb-4">My Decks</h2>
                <div id="deck-list"></div>
            </div>
            <button class="fab" id="add-deck-fab">
                <i class="fa-solid fa-plus"></i>
            </button>
        </div>

        <!-- Review View -->
        <div id="view-review" class="view">
            <div class="flashcard-container">
                <div class="flashcard" id="card-content">
                    <div class="text-gray-500">Tap to start studying...</div>
                </div>
            </div>
            
            <div id="answer-controls" class="review-controls hidden">
                <button class="btn-answer btn-again" data-rating="1">Again<small>1m</small></button>
                <button class="btn-answer btn-hard" data-rating="2">Hard<small>10m</small></button>
                <button class="btn-answer btn-good" data-rating="3">Good<small>1d</small></button>
                <button class="btn-answer btn-easy" data-rating="4">Easy<small>4d</small></button>
            </div>
            
            <div id="show-answer-control" class="review-controls">
                <button class="btn-answer" style="background: var(--card-bg);" id="show-answer-btn">
                    Show Answer
                </button>
            </div>
        </div>

        <!-- Add Card View -->
        <div id="view-add" class="view">
            <div class="form-container">
                <h2 class="text-lg font-bold mb-6">Add New Card</h2>
                
                <div class="form-group">
                    <label class="form-label">Deck</label>
                    <select class="form-select" id="deck-select">
                        <option value="">Loading decks...</option>
                    </select>
                </div>

                <div class="form-group">
                    <label class="form-label">Card Type</label>
                    <select class="form-select" id="card-type">
                        <option value="basic">Basic</option>
                        <option value="basic-rev">Basic (and Reversed Card)</option>
                        <option value="cloze">Cloze</option>
                        <option value="cloze+">Cloze+ (Multiple deletions)</option>
                    </select>
                </div>

                <div id="fields-container">
                    <div class="form-group">
                        <label class="form-label" id="front-label">Front</label>
                        <textarea class="form-textarea" id="front-field" placeholder="Enter question or text..."></textarea>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label" id="back-label">Back</label>
                        <textarea class="form-textarea" id="back-field" placeholder="Enter answer or additional information..."></textarea>
                    </div>
                </div>

                <div class="cloze-examples hidden" id="cloze-examples">
                    <h4>Cloze Syntax Examples:</h4>
                    <p>• Basic cloze: <code>{{c1::capital}} of France</code></p>
                    <p>• Multiple clozes: <code>{{c1::Paris}} is the {{c2::capital}} of {{c3::France}}</code></p>
                    <p>• Cloze with hint: <code>{{c1::Paris::capital city}}</code></p>
                </div>

                <button class="form-button" id="save-card-btn">Add Card</button>
            </div>
        </div>

        <!-- Browser View -->
        <div id="view-browse" class="view">
            <div class="form-container">
                <input type="text" class="form-input mb-4" id="search-input" placeholder="Search cards...">
                <div id="browser-content"></div>
            </div>
        </div>

        <!-- Stats View -->
        <div id="view-stats" class="view">
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value text-blue-500" id="stat-total">0</div>
                    <div class="stat-label">Total Cards</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value text-green-500" id="stat-due">0</div>
                    <div class="stat-label">Due Today</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value text-yellow-500" id="stat-learn">0</div>
                    <div class="stat-label">Learning</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value text-purple-500" id="stat-review">0</div>
                    <div class="stat-label">To Review</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Tab Bar -->
    <div class="tab-bar">
        <div class="tab-item active" data-view="decks">
            <i class="fa-solid fa-layer-group"></i>
            <span>Decks</span>
        </div>
        <div class="tab-item" data-view="review">
            <i class="fa-solid fa-graduation-cap"></i>
            <span>Study</span>
        </div>
        <div class="tab-item" data-view="add">
            <i class="fa-solid fa-plus-circle"></i>
            <span>Add</span>
        </div>
        <div class="tab-item" data-view="browse">
            <i class="fa-solid fa-magnifying-glass"></i>
            <span>Browse</span>
        </div>
        <div class="tab-item" data-view="stats">
            <i class="fa-solid fa-chart-simple"></i>
            <span>Stats</span>
        </div>
    </div>

    <script>
    // Anki iOS App - Made by Muhammad Daler
    class AnkiApp {
        constructor() {
            this.db = null;
            this.currentDeck = null;
            this.studyQueue = [];
            this.currentCard = null;
            this.currentNote = null;
            this.isShowingAnswer = false;
            this.timerStart = null;
            this.timerInterval = null;
            
            this.init();
        }

        async init() {
            try {
                await this.initDatabase();
                await this.loadInitialData();
                this.setupEventListeners();
                this.setupTabs();
                this.updateCardTypeUI();
                this.renderDeckList();
                this.updateDeckSelect();
                this.updateStats();
                
                console.log('Anki iOS App initialized successfully');
            } catch (error) {
                console.error('Failed to initialize app:', error);
                this.showError('Failed to initialize app. Please refresh.');
            }
        }

        initDatabase() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('AnkiiOSDB', 3);
                
                request.onerror = () => reject(request.error);
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    
                    // Create decks store
                    if (!db.objectStoreNames.contains('decks')) {
                        const deckStore = db.createObjectStore('decks', { keyPath: 'id' });
                        deckStore.createIndex('name', 'name', { unique: true });
                    }
                    
                    // Create notes store
                    if (!db.objectStoreNames.contains('notes')) {
                        const noteStore = db.createObjectStore('notes', { keyPath: 'id' });
                        noteStore.createIndex('deckId', 'deckId', { unique: false });
                        noteStore.createIndex('type', 'type', { unique: false });
                    }
                    
                    // Create cards store
                    if (!db.objectStoreNames.contains('cards')) {
                        const cardStore = db.createObjectStore('cards', { keyPath: 'id' });
                        cardStore.createIndex('deckId', 'deckId', { unique: false });
                        cardStore.createIndex('noteId', 'noteId', { unique: false });
                        cardStore.createIndex('due', 'due', { unique: false });
                        cardStore.createIndex('type', 'type', { unique: false });
                    }
                    
                    // Create revlog store
                    if (!db.objectStoreNames.contains('revlog')) {
                        const revlogStore = db.createObjectStore('revlog', { keyPath: 'id' });
                        revlogStore.createIndex('cardId', 'cardId', { unique: false });
                    }
                };
                
                request.onsuccess = (event) => {
                    this.db = event.target.result;
                    resolve();
                };
            });
        }

        async loadInitialData() {
            // Create default deck if none exists
            const decks = await this.getAll('decks');
            if (decks.length === 0) {
                await this.add('decks', {
                    id: Date.now(),
                    name: 'Default',
                    created: Date.now(),
                    desc: 'Default deck'
                });
            }
        }

        // Database operations
        async getAll(storeName) {
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.getAll();
                
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async get(storeName, key) {
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.get(key);
                
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async add(storeName, data) {
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.add(data);
                
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async put(storeName, data) {
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.put(data);
                
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        async delete(storeName, key) {
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.delete(key);
                
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        // Navigation
        setupTabs() {
            document.querySelectorAll('.tab-item').forEach(tab => {
                tab.addEventListener('click', (e) => {
                    const view = e.currentTarget.dataset.view;
                    this.switchView(view);
                });
            });
        }

        switchView(viewName) {
            // Hide all views
            document.querySelectorAll('.view').forEach(view => {
                view.classList.remove('active');
            });
            
            // Show selected view
            const targetView = document.getElementById(`view-${viewName}`);
            if (targetView) {
                targetView.classList.add('active');
            }
            
            // Update tabs
            document.querySelectorAll('.tab-item').forEach(tab => {
                tab.classList.remove('active');
                if (tab.dataset.view === viewName) {
                    tab.classList.add('active');
                }
            });
            
            // Update header title
            const titles = {
                'decks': 'My Decks',
                'review': 'Study',
                'add': 'Add Card',
                'browse': 'Browse Cards',
                'stats': 'Statistics'
            };
            document.getElementById('header-title').textContent = titles[viewName] || 'Anki iOS';
            
            // Refresh data for the view
            switch(viewName) {
                case 'decks':
                    this.renderDeckList();
                    break;
                case 'browse':
                    this.renderBrowser();
                    break;
                case 'stats':
                    this.updateStats();
                    break;
            }
        }

        // Deck Management
        async renderDeckList() {
            const container = document.getElementById('deck-list');
            container.innerHTML = '';
            
            try {
                const decks = await this.getAll('decks');
                const cards = await this.getAll('cards');
                
                if (decks.length === 0) {
                    container.innerHTML = '<div class="error">No decks found. Create your first deck!</div>';
                    return;
                }
                
                const now = Date.now();
                const today = Math.floor(now / 86400000);
                
                for (const deck of decks) {
                    const deckCards = cards.filter(card => card.deckId === deck.id);
                    
                    // Calculate counts
                    const newCount = deckCards.filter(c => c.type === 0).length;
                    const learnCount = deckCards.filter(c => 
                        (c.type === 1 || c.type === 3) && c.due < now / 1000
                    ).length;
                    const reviewCount = deckCards.filter(c => 
                        c.type === 2 && c.due <= today
                    ).length;
                    
                    const deckElement = document.createElement('div');
                    deckElement.className = 'deck-item';
                    deckElement.innerHTML = `
                        <div>
                            <div class="font-semibold text-lg">${deck.name}</div>
                            <div class="text-sm text-gray-500 mt-1">${deckCards.length} cards</div>
                        </div>
                        <div class="deck-counts">
                            <div class="count-new">${newCount}</div>
                            <div class="count-learn">${learnCount}</div>
                            <div class="count-review">${reviewCount}</div>
                        </div>
                    `;
                    
                    deckElement.addEventListener('click', () => this.startStudySession(deck.id));
                    container.appendChild(deckElement);
                }
            } catch (error) {
                console.error('Error rendering deck list:', error);
                container.innerHTML = '<div class="error">Error loading decks</div>';
            }
        }

        async startStudySession(deckId) {
            try {
                this.currentDeck = deckId;
                const deck = await this.get('decks', deckId);
                if (!deck) {
                    this.showError('Deck not found');
                    return;
                }
                
                // Build study queue
                await this.buildStudyQueue(deckId);
                
                if (this.studyQueue.length === 0) {
                    this.showMessage('No cards to study right now!');
                    return;
                }
                
                this.switchView('review');
                this.startTimer();
                this.showNextCard();
            } catch (error) {
                console.error('Error starting study session:', error);
                this.showError('Failed to start study session');
            }
        }

        async buildStudyQueue(deckId) {
            try {
                const cards = await this.getAll('cards');
                const deckCards = cards.filter(card => card.deckId === deckId);
                
                const now = Date.now();
                const today = Math.floor(now / 86400000);
                
                // Sort cards by priority
                const learningCards = deckCards.filter(card => 
                    (card.type === 1 || card.type === 3) && card.due < now / 1000
                ).sort((a, b) => a.due - b.due);
                
                const reviewCards = deckCards.filter(card => 
                    card.type === 2 && card.due <= today
                ).sort((a, b) => a.due - b.due);
                
                const newCards = deckCards.filter(card => card.type === 0).slice(0, 20);
                
                this.studyQueue = [...learningCards, ...reviewCards, ...newCards];
            } catch (error) {
                console.error('Error building study queue:', error);
                this.studyQueue = [];
            }
        }

        // Card Study
        async showNextCard() {
            if (this.studyQueue.length === 0) {
                this.endStudySession();
                return;
            }
            
            this.currentCard = this.studyQueue.shift();
            this.currentNote = await this.get('notes', this.currentCard.noteId);
            this.isShowingAnswer = false;
            
            this.renderCardFront();
            
            // Show answer button, hide rating buttons
            document.getElementById('show-answer-control').classList.remove('hidden');
            document.getElementById('answer-controls').classList.add('hidden');
        }

        renderCardFront() {
            const container = document.getElementById('card-content');
            
            if (!this.currentNote) {
                container.innerHTML = '<div class="error">Error loading card</div>';
                return;
            }
            
            let content = '';
            
            switch(this.currentNote.type) {
                case 'cloze':
                case 'cloze+':
                    content = this.renderClozeFront();
                    break;
                case 'basic-rev':
                    if (this.currentCard.ord === 1) {
                        // Reversed card
                        content = this.formatText(this.currentNote.back);
                    } else {
                        // Normal card
                        content = this.formatText(this.currentNote.front);
                    }
                    break;
                default:
                    content = this.formatText(this.currentNote.front);
            }
            
            container.innerHTML = `<div class="card-content">${content}</div>`;
        }

        renderClozeFront() {
            let text = this.currentNote.front;
            const clozeNumber = this.currentCard.clozeNumber || 1;
            
            // Replace the current cloze with blanks, show others
            const regex = new RegExp(`{{c${clozeNumber}::(.*?)}}`, 'g');
            text = text.replace(regex, '<span class="cloze-blank">[...]</span>');
            
            // Remove other cloze markers
            text = text.replace(/{{c\d+::(.*?)}}/g, '$1');
            
            return this.formatText(text);
        }

        showAnswer() {
            if (!this.currentNote || this.isShowingAnswer) return;
            
            this.isShowingAnswer = true;
            const container = document.getElementById('card-content');
            
            let content = '';
            
            switch(this.currentNote.type) {
                case 'cloze':
                case 'cloze+':
                    content = this.renderClozeAnswer();
                    break;
                case 'basic-rev':
                    if (this.currentCard.ord === 1) {
                        content = `
                            <div class="mb-6">${this.formatText(this.currentNote.back)}</div>
                            <div class="border-t border-gray-600 pt-6">${this.formatText(this.currentNote.front)}</div>
                        `;
                    } else {
                        content = `
                            <div class="mb-6">${this.formatText(this.currentNote.front)}</div>
                            <div class="border-t border-gray-600 pt-6">${this.formatText(this.currentNote.back)}</div>
                        `;
                    }
                    break;
                default:
                    content = `
                        <div class="mb-6">${this.formatText(this.currentNote.front)}</div>
                        <div class="border-t border-gray-600 pt-6">${this.formatText(this.currentNote.back)}</div>
                    `;
            }
            
            container.innerHTML = `<div class="card-content">${content}</div>`;
            
            // Show rating buttons, hide answer button
            document.getElementById('show-answer-control').classList.add('hidden');
            document.getElementById('answer-controls').classList.remove('hidden');
        }

        renderClozeAnswer() {
            let text = this.currentNote.front;
            const clozeNumber = this.currentCard.clozeNumber || 1;
            
            // Highlight the current cloze
            const regex = new RegExp(`{{c${clozeNumber}::(.*?)}}`, 'g');
            text = text.replace(regex, '<span class="cloze">$1</span>');
            
            // Remove other cloze markers
            text = text.replace(/{{c\d+::(.*?)}}/g, '$1');
            
            let content = `<div class="mb-6">${this.formatText(text)}</div>`;
            
            // Add back content if exists
            if (this.currentNote.back) {
                content += `<div class="border-t border-gray-600 pt-6">${this.formatText(this.currentNote.back)}</div>`;
            }
            
            return content;
        }

        async answerCard(rating) {
            try {
                if (!this.currentCard) return;
                
                // Update card using SM-2 algorithm
                const updatedCard = this.applySM2(this.currentCard, rating);
                
                // Save updated card
                await this.put('cards', updatedCard);
                
                // Log review
                await this.add('revlog', {
                    id: Date.now(),
                    cardId: this.currentCard.id,
                    rating: rating,
                    time: Math.floor((Date.now() - this.timerStart) / 1000),
                    date: Date.now()
                });
                
                // Show next card
                this.startTimer();
                this.showNextCard();
            } catch (error) {
                console.error('Error answering card:', error);
                this.showError('Failed to save answer');
            }
        }

        applySM2(card, rating) {
            const now = Date.now();
            const today = Math.floor(now / 86400000);
            
            let newType = card.type;
            let newInterval = card.interval || 0;
            let newDue = card.due;
            let newEase = card.ease || 2.5;
            let newReviews = card.reviews + 1;
            let newLapses = card.lapses;
            
            // SM-2 Algorithm
            if (card.type === 0) { // New card
                if (rating >= 3) {
                    newType = 2; // Review
                    newInterval = 1; // 1 day
                    newDue = today + newInterval;
                } else {
                    newType = 1; // Learning
                    newInterval = 1; // 1 minute
                    newDue = now / 1000 + newInterval;
                }
            } else if (card.type === 1 || card.type === 3) { // Learning or Relearning
                if (rating >= 3) {
                    newType = 2;
                    newInterval = 1;
                    newDue = today + newInterval;
                } else {
                    newInterval = 1;
                    newDue = now / 1000 + newInterval;
                }
            } else if (card.type === 2) { // Review
                if (rating === 1) { // Again
                    newType = 3; // Relearning
                    newEase = Math.max(1.3, newEase - 0.2);
                    newLapses++;
                    newInterval = 1;
                    newDue = now / 1000 + newInterval;
                } else {
                    newEase = newEase + (rating - 3) * 0.15;
                    newEase = Math.max(1.3, Math.min(newEase, 5.0));
                    
                    if (rating === 2) { // Hard
                        newInterval = Math.max(1, Math.floor(newInterval * 1.2));
                    } else if (rating === 3) { // Good
                        newInterval = Math.floor(newInterval * newEase);
                    } else if (rating === 4) { // Easy
                        newInterval = Math.floor(newInterval * newEase * 1.3);
                    }
                    
                    newDue = today + newInterval;
                }
            }
            
            return {
                ...card,
                type: newType,
                interval: newInterval,
                due: newDue,
                ease: newEase,
                reviews: newReviews,
                lapses: newLapses,
                lastReviewed: now
            };
        }

        // Card Creation
        updateCardTypeUI() {
            const cardType = document.getElementById('card-type');
            const clozeExamples = document.getElementById('cloze-examples');
            const frontLabel = document.getElementById('front-label');
            const backLabel = document.getElementById('back-label');
            
            cardType.addEventListener('change', () => {
                const type = cardType.value;
                
                if (type === 'cloze' || type === 'cloze+') {
                    clozeExamples.classList.remove('hidden');
                    frontLabel.textContent = 'Text (use {{c1::cloze}} syntax)';
                    backLabel.textContent = 'Extra Information (optional)';
                } else {
                    clozeExamples.classList.add('hidden');
                    frontLabel.textContent = 'Front';
                    backLabel.textContent = 'Back';
                }
            });
        }

        async updateDeckSelect() {
            const select = document.getElementById('deck-select');
            
            try {
                const decks = await this.getAll('decks');
                select.innerHTML = '';
                
                if (decks.length === 0) {
                    select.innerHTML = '<option value="">No decks available</option>';
                    return;
                }
                
                decks.forEach(deck => {
                    const option = document.createElement('option');
                    option.value = deck.id;
                    option.textContent = deck.name;
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('Error loading decks:', error);
                select.innerHTML = '<option value="">Error loading decks</option>';
            }
        }

        async saveCard() {
            try {
                const deckId = document.getElementById('deck-select').value;
                const cardType = document.getElementById('card-type').value;
                const front = document.getElementById('front-field').value.trim();
                const back = document.getElementById('back-field').value.trim();
                
                // Validation
                if (!deckId) {
                    this.showError('Please select a deck');
                    return;
                }
                
                if (!front) {
                    this.showError('Front field cannot be empty');
                    return;
                }
                
                if ((cardType === 'basic' || cardType === 'basic-rev') && !back) {
                    this.showError('Back field cannot be empty for basic cards');
                    return;
                }
                
                // Create note
                const noteId = Date.now();
                const note = {
                    id: noteId,
                    deckId: parseInt(deckId),
                    type: cardType,
                    front: front,
                    back: back,
                    created: Date.now()
                };
                
                await this.add('notes', note);
                
                // Create cards based on type
                if (cardType === 'basic') {
                    await this.createBasicCard(noteId, deckId, 0);
                } 
                else if (cardType === 'basic-rev') {
                    // Front card
                    await this.createBasicCard(noteId, deckId, 0);
                    // Back card (reversed)
                    await this.createBasicCard(noteId, deckId, 1);
                }
                else if (cardType === 'cloze' || cardType === 'cloze+') {
                    await this.createClozeCards(noteId, deckId, front);
                }
                
                // Clear form
                document.getElementById('front-field').value = '';
                document.getElementById('back-field').value = '';
                
                this.showMessage('Card added successfully!');
                
                // Update stats
                this.updateStats();
                
            } catch (error) {
                console.error('Error saving card:', error);
                this.showError('Failed to save card: ' + error.message);
            }
        }

        async createBasicCard(noteId, deckId, ord) {
            const cardId = Date.now() + ord;
            const card = {
                id: cardId,
                noteId: noteId,
                deckId: parseInt(deckId),
                ord: ord,
                type: 0, // New
                interval: 0,
                ease: 2.5,
                due: 0,
                reviews: 0,
                lapses: 0,
                created: Date.now()
            };
            
            await this.add('cards', card);
        }

        async createClozeCards(noteId, deckId, text) {
            // Extract all cloze numbers from text
            const clozeRegex = /{{c(\d+)::(.*?)}}/g;
            const matches = [...text.matchAll(clozeRegex)];
            const clozeNumbers = [...new Set(matches.map(m => parseInt(m[1])))];
            
            // If no cloze found, create one card
            if (clozeNumbers.length === 0) {
                clozeNumbers.push(1);
            }
            
            // Create a card for each cloze
            for (let i = 0; i < clozeNumbers.length; i++) {
                const cardId = Date.now() + i;
                const card = {
                    id: cardId,
                    noteId: noteId,
                    deckId: parseInt(deckId),
                    clozeNumber: clozeNumbers[i],
                    type: 0, // New
                    interval: 0,
                    ease: 2.5,
                    due: 0,
                    reviews: 0,
                    lapses: 0,
                    created: Date.now()
                };
                
                await this.add('cards', card);
            }
        }

        // Browser
        async renderBrowser(query = '') {
            const container = document.getElementById('browser-content');
            container.innerHTML = '';
            
            try {
                const notes = await this.getAll('notes');
                const decks = await this.getAll('decks');
                
                let filteredNotes = notes;
                if (query) {
                    const searchTerm = query.toLowerCase();
                    filteredNotes = notes.filter(note => 
                        note.front.toLowerCase().includes(searchTerm) ||
                        note.back.toLowerCase().includes(searchTerm)
                    );
                }
                
                if (filteredNotes.length === 0) {
                    container.innerHTML = '<div class="error">No cards found</div>';
                    return;
                }
                
                for (const note of filteredNotes.slice(0, 50)) {
                    const deck = decks.find(d => d.id === note.deckId);
                    const cards = (await this.getAll('cards')).filter(c => c.noteId === note.id);
                    
                    const noteElement = document.createElement('div');
                    noteElement.className = 'browser-item';
                    noteElement.innerHTML = `
                        <div class="font-semibold mb-2">${this.formatText(note.front.substring(0, 200))}</div>
                        <div class="text-sm text-gray-500">
                            ${deck ? deck.name : 'Unknown'} • ${cards.length} card(s) • ${note.type}
                        </div>
                    `;
                    
                    container.appendChild(noteElement);
                }
            } catch (error) {
                console.error('Error rendering browser:', error);
                container.innerHTML = '<div class="error">Error loading cards</div>';
            }
        }

        // Stats
        async updateStats() {
            try {
                const cards = await this.getAll('cards');
                const now = Date.now();
                const today = Math.floor(now / 86400000);
                
                // Calculate stats
                const totalCards = cards.length;
                
                const dueToday = cards.filter(card => {
                    if (card.type === 0) return true; // New cards
                    if (card.type === 1 || card.type === 3) return card.due < now / 1000;
                    if (card.type === 2) return card.due <= today;
                    return false;
                }).length;
                
                const learningCards = cards.filter(card => 
                    (card.type === 1 || card.type === 3) && card.due < now / 1000
                ).length;
                
                const reviewCards = cards.filter(card => 
                    card.type === 2 && card.due <= today
                ).length;
                
                // Update UI
                document.getElementById('stat-total').textContent = totalCards;
                document.getElementById('stat-due').textContent = dueToday;
                document.getElementById('stat-learn').textContent = learningCards;
                document.getElementById('stat-review').textContent = reviewCards;
            } catch (error) {
                console.error('Error updating stats:', error);
            }
        }

        // Utility Methods
        formatText(text) {
            if (!text) return '';
            
            return text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/\n/g, '<br>')
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                .replace(/`(.*?)`/g, '<code>$1</code>');
        }

        startTimer() {
            this.timerStart = Date.now();
        }

        endStudySession() {
            this.showMessage('Study session complete!');
            this.switchView('decks');
        }

        showError(message) {
            alert('Error: ' + message);
        }

        showMessage(message) {
            alert(message);
        }

        // Event Listeners
        setupEventListeners() {
            // Add deck FAB
            document.getElementById('add-deck-fab').addEventListener('click', () => {
                this.createNewDeck();
            });
            
            // Save card button
            document.getElementById('save-card-btn').addEventListener('click', () => {
                this.saveCard();
            });
            
            // Show answer button
            document.getElementById('show-answer-btn').addEventListener('click', () => {
                this.showAnswer();
            });
            
            // Card flip on click
            document.getElementById('card-content').addEventListener('click', () => {
                if (!this.isShowingAnswer) {
                    this.showAnswer();
                }
            });
            
            // Answer buttons
            document.querySelectorAll('.btn-answer').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const rating = parseInt(e.currentTarget.dataset.rating);
                    this.answerCard(rating);
                });
            });
            
            // Search input
            document.getElementById('search-input').addEventListener('input', (e) => {
                this.renderBrowser(e.target.value);
            });
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT') {
                    return;
                }
                
                if (!this.isShowingAnswer && e.code === 'Space') {
                    this.showAnswer();
                    e.preventDefault();
                } else if (this.isShowingAnswer) {
                    switch(e.code) {
                        case 'Digit1':
                        case 'Numpad1':
                            this.answerCard(1);
                            e.preventDefault();
                            break;
                        case 'Digit2':
                        case 'Numpad2':
                            this.answerCard(2);
                            e.preventDefault();
                            break;
                        case 'Digit3':
                        case 'Numpad3':
                            this.answerCard(3);
                            e.preventDefault();
                            break;
                        case 'Digit4':
                        case 'Numpad4':
                            this.answerCard(4);
                            e.preventDefault();
                            break;
                    }
                }
            });
        }

        async createNewDeck() {
            const name = prompt('Enter deck name:');
            if (!name || !name.trim()) return;
            
            try {
                const deck = {
                    id: Date.now(),
                    name: name.trim(),
                    created: Date.now(),
                    desc: ''
                };
                
                await this.add('decks', deck);
                this.showMessage('Deck created successfully!');
                
                // Update UI
                this.renderDeckList();
                this.updateDeckSelect();
                this.updateStats();
            } catch (error) {
                console.error('Error creating deck:', error);
                this.showError('Failed to create deck');
            }
        }
    }

    // Initialize app when page loads
    document.addEventListener('DOMContentLoaded', () => {
        window.ankiApp = new AnkiApp();
    });
    </script>
</body>
</html>