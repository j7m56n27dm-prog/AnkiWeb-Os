<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Anki macOS - Made by ©️Muhammad Daler</title>
    
    <!-- React 18 & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel for JSX compilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        darkMode: 'class',
        theme: {
          extend: {
            colors: {
              ios: {
                blue: '#007AFF',
                green: '#34C759',
                red: '#FF3B30',
                yellow: '#FF9500',
                gray: '#8E8E93',
                bg: '#F2F2F7',
                darkBg: '#000000',
                card: '#FFFFFF',
                darkCard: '#1C1C1E'
              }
            }
          }
        }
      }
    </script>
    
    <!-- FontAwesome -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    
    <!-- DOMPurify for XSS protection -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.1.6/purify.min.js"></script>
    
    <style>
      /* Force San Francisco / System Fonts */
      body {
        font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Helvetica Neue", sans-serif;
        background-color: #F2F2F7;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        overscroll-behavior-y: none;
        transition: background-color 0.3s ease;
        margin: 0;
        padding: 0;
      }

      /* Dark Mode */
      html.dark body {
        background-color: #000000;
      }
      
      /* Hide Scrollbar */
      ::-webkit-scrollbar {
        display: none;
      }
      
      /* Cloze Styles */
      .cloze-hidden {
        color: #007AFF;
        font-weight: 700;
        background: rgba(0, 122, 255, 0.12);
        padding: 2px 6px;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s;
        border: 1px dashed rgba(0, 122, 255, 0.3);
        user-select: none;
      }

      html.dark .cloze-hidden {
        color: #409CFF;
        background: rgba(10, 132, 255, 0.25);
        border-color: rgba(64, 156, 255, 0.4);
      }

      .cloze-revealed {
        color: #34C759;
        font-weight: 700;
        text-decoration: underline;
        text-decoration-thickness: 2px;
      }

      html.dark .cloze-revealed {
        color: #30D158;
      }

      /* Card Flip Animation */
      .card-container {
        perspective: 1000px;
      }
      
      .card-inner {
        position: relative;
        width: 100%;
        height: 100%;
        transition: transform 0.6s cubic-bezier(0.2, 0.8, 0.2, 1);
        transform-style: preserve-3d;
      }
      
      .card-flipped .card-inner {
        transform: rotateY(180deg);
      }
      
      .card-front, .card-back {
        position: absolute;
        width: 100%;
        height: 100%;
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
      }
      
      .card-back {
        transform: rotateY(180deg);
      }

      /* Native-like interactions */
      * {
        -webkit-tap-highlight-color: transparent;
        touch-action: manipulation;
      }

      /* Loading Skeleton */
      .skeleton {
        background: linear-gradient(
          90deg,
          rgba(190, 190, 190, 0.2) 25%,
          rgba(129, 129, 129, 0.24) 37%,
          rgba(190, 190, 190, 0.2) 63%
        );
        background-size: 400% 100%;
        animation: skeleton-loading 1.4s ease infinite;
      }

      @keyframes skeleton-loading {
        0% { background-position: 100% 50%; }
        100% { background-position: 0 50%; }
      }

      /* Animations */
      @keyframes fade-in-up {
        from { opacity: 0; transform: translateY(20px); }
        to { opacity: 1; transform: translateY(0); }
      }
      
      @keyframes scale-up {
        from { opacity: 0; transform: scale(0.95); }
        to { opacity: 1; transform: scale(1); }
      }
      
      @keyframes fade-in {
        from { opacity: 0; }
        to { opacity: 1; }
      }
      
      @keyframes slide-up {
        from { transform: translateY(100%); }
        to { transform: translateY(0); }
      }

      .animate-fade-in-up { animation: fade-in-up 0.5s ease-out forwards; }
      .animate-scale-up { animation: scale-up 0.2s ease-out forwards; }
      .animate-fade-in { animation: fade-in 0.3s ease-out forwards; }
      .animate-slide-up { animation: slide-up 0.3s ease-out forwards; }
      
      /* Safe area for iOS */
      .pb-safe {
        padding-bottom: env(safe-area-inset-bottom, 20px);
      }
    </style>
</head>
<body class="antialiased">
    <div id="root"></div>

    <!-- Application Code -->
    <script type="text/babel">
        const { useState, useEffect, useRef, Fragment } = React;

        // ==========================================
        // UTILS: Security & Sanitization
        // ==========================================
        const SecurityUtils = {
            sanitizeHTML(html) {
                if (typeof html !== 'string') return '';
                return DOMPurify.sanitize(html, {
                    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'u', 'br', 'div', 'span', 'p', 'code', 'pre'],
                    ALLOWED_ATTR: ['class', 'title', 'style'],
                    RETURN_DOM_FRAGMENT: false,
                    RETURN_DOM: false
                });
            },

            validateInput(text, maxLength = 10000) {
                if (typeof text !== 'string') return false;
                if (text.length > maxLength) return false;
                if (text.includes('<script>') || text.includes('javascript:')) return false;
                return true;
            }
        };

        // ==========================================
        // UTILS: Cloze Parser
        // ==========================================
        const getClozeIndices = (text) => {
            const regex = /{{c(\d+)::(.*?)}}/gs;
            const indices = new Set();
            let match;
            regex.lastIndex = 0;
            while ((match = regex.exec(text)) !== null) {
                const num = parseInt(match[1], 10);
                if (!isNaN(num)) indices.add(num);
            }
            return Array.from(indices).sort((a, b) => a - b);
        };

        const generateClozeContent = (text, ord) => {
            const regex = /{{c(\d+)::(.*?)}}/gs;
            
            const processText = (isFront) => {
                return text.replace(regex, (match, numStr, inside) => {
                    const index = parseInt(numStr, 10);
                    let answer = inside;
                    let hint = "";
                    const separatorIdx = inside.indexOf("::");
                    
                    if (separatorIdx !== -1) {
                        answer = inside.substring(0, separatorIdx);
                        hint = inside.substring(separatorIdx + 2);
                    }

                    if (index === ord) {
                        if (isFront) {
                            const display = hint ? `[${hint}]` : '[...]';
                            return `<span class="cloze-hidden" title="Show Answer">${display}</span>`;
                        } else {
                            return `<span class="cloze-revealed">${answer}</span>`;
                        }
                    } else {
                        return answer;
                    }
                });
            };

            return { 
                front: SecurityUtils.sanitizeHTML(processText(true).replace(/\n/g, '<br>')), 
                back: SecurityUtils.sanitizeHTML(processText(false).replace(/\n/g, '<br>')) 
            };
        };

        // ==========================================
        // UTILS: Scheduler
        // ==========================================
        const LEARN_STEPS = [1 * 60 * 1000, 10 * 60 * 1000];
        const GRADUATING_INTERVAL = 1;
        const EASY_INTERVAL = 4;
        const STARTING_EASE = 2.5;

        const scheduleCard = (card, rating) => {
            const now = Date.now();
            const newCard = { ...card };
            
            if (newCard.queue === 'new' || newCard.queue === 'learning') {
                if (rating === 1) {
                    newCard.queue = 'learning';
                    newCard.due = now + LEARN_STEPS[0];
                    newCard.interval = 0;
                } else if (rating === 2) {
                    newCard.due = now + (LEARN_STEPS[0] * 1.5);
                } else if (rating === 3) {
                    if (newCard.interval === 0) {
                        newCard.interval = 1; 
                        newCard.due = now + LEARN_STEPS[1];
                        newCard.queue = 'learning';
                    } else {
                        newCard.queue = 'review';
                        newCard.interval = GRADUATING_INTERVAL;
                        newCard.due = now + (GRADUATING_INTERVAL * 24 * 60 * 60 * 1000);
                        newCard.ease = STARTING_EASE;
                    }
                } else if (rating === 4) {
                    newCard.queue = 'review';
                    newCard.interval = EASY_INTERVAL;
                    newCard.due = now + (EASY_INTERVAL * 24 * 60 * 60 * 1000);
                    newCard.ease = STARTING_EASE;
                }
            } else {
                if (rating === 1) {
                    newCard.queue = 'learning';
                    newCard.due = now + LEARN_STEPS[0];
                    newCard.interval = 1;
                    newCard.ease = Math.max(1.3, newCard.ease - 0.2);
                    newCard.lapses += 1;
                } else {
                    if (rating === 2) {
                        newCard.ease = Math.max(1.3, newCard.ease - 0.15);
                        newCard.interval = newCard.interval * 1.2;
                    } else if (rating === 3) {
                        newCard.interval = newCard.interval * newCard.ease;
                    } else if (rating === 4) {
                        newCard.ease += 0.15;
                        newCard.interval = newCard.interval * newCard.ease * 1.3;
                    }
                    newCard.due = now + (newCard.interval * 24 * 60 * 60 * 1000);
                }
            }
            newCard.reps += 1;
            
            const log = {
                id: crypto.randomUUID(),
                cardId: card.id,
                rating,
                time: now,
                lastInterval: card.interval,
                newInterval: newCard.interval
            };
            
            return { card: newCard, log };
        };

        // ==========================================
        // SERVICE: Database (IndexedDB)
        // ==========================================
        const DB_NAME = 'AnkiMacOS_DB';
        const DB_VERSION = 1;

        const initDB = () => {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve(request.result);
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('decks')) db.createObjectStore('decks', { keyPath: 'id' });
                    if (!db.objectStoreNames.contains('notes')) db.createObjectStore('notes', { keyPath: 'id' });
                    if (!db.objectStoreNames.contains('cards')) {
                        const store = db.createObjectStore('cards', { keyPath: 'id' });
                        store.createIndex('deckId', 'deckId', { unique: false });
                        store.createIndex('due', 'due', { unique: false });
                    }
                    if (!db.objectStoreNames.contains('logs')) {
                        const store = db.createObjectStore('logs', { keyPath: 'id' });
                        store.createIndex('cardId', 'cardId', { unique: false });
                    }
                };
            });
        };

        const dbService = {
            async getAllDecks() {
                const db = await initDB();
                return new Promise((resolve) => {
                    const tx = db.transaction('decks', 'readonly');
                    const req = tx.objectStore('decks').getAll();
                    req.onsuccess = () => resolve(req.result);
                });
            },
            async addDeck(name) {
                const db = await initDB();
                const deck = { id: crypto.randomUUID(), name, created: Date.now(), cardCount: 0 };
                return new Promise((resolve, reject) => {
                    const tx = db.transaction('decks', 'readwrite');
                    tx.objectStore('decks').add(deck);
                    tx.oncomplete = () => resolve(deck);
                    tx.onerror = () => reject(tx.error);
                });
            },
            async addNote(note, cards) {
                const db = await initDB();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(['notes', 'cards'], 'readwrite');
                    tx.objectStore('notes').add(note);
                    const cardStore = tx.objectStore('cards');
                    cards.forEach(card => cardStore.add(card));
                    
                    // Update deck card count
                    const deckStore = tx.objectStore('decks');
                    const deckRequest = deckStore.get(note.deckId);
                    deckRequest.onsuccess = () => {
                        const deck = deckRequest.result;
                        if (deck) {
                            deck.cardCount = (deck.cardCount || 0) + cards.length;
                            deckStore.put(deck);
                        }
                    };
                    
                    tx.oncomplete = () => resolve();
                    tx.onerror = () => reject(tx.error);
                });
            },
            async getDueCards(deckId) {
                const db = await initDB();
                return new Promise((resolve) => {
                    const tx = db.transaction('cards', 'readonly');
                    const store = tx.objectStore('cards');
                    const index = store.index('deckId');
                    const req = index.getAll(deckId);
                    req.onsuccess = () => {
                        const allCards = req.result;
                        const now = Date.now();
                        const dueCards = allCards.filter(c => {
                            if (c.queue === 'new') return true;
                            if (c.queue === 'learning') return c.due <= now;
                            if (c.queue === 'review') return c.due <= now;
                            return false;
                        }).sort((a, b) => a.due - b.due);
                        resolve(dueCards);
                    };
                });
            },
            async updateCard(card, log) {
                const db = await initDB();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(['cards', 'logs'], 'readwrite');
                    tx.objectStore('cards').put(card);
                    tx.objectStore('logs').add(log);
                    tx.oncomplete = () => resolve();
                    tx.onerror = () => reject(tx.error);
                });
            },
            async deleteDeck(id) {
                const db = await initDB();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(['decks', 'cards', 'notes'], 'readwrite');
                    tx.objectStore('decks').delete(id);
                    const cardStore = tx.objectStore('cards');
                    const cardIndex = cardStore.index('deckId');
                    const cardRequest = cardIndex.getAllKeys(id);
                    cardRequest.onsuccess = () => {
                        cardRequest.result.forEach(key => cardStore.delete(key));
                    };
                    const noteStore = tx.objectStore('notes');
                    const noteRequest = noteStore.openCursor();
                    noteRequest.onsuccess = (event) => {
                        const cursor = event.target.result;
                        if (cursor) {
                            if (cursor.value.deckId === id) cursor.delete();
                            cursor.continue();
                        }
                    };
                    tx.oncomplete = () => resolve();
                    tx.onerror = () => reject(tx.error);
                });
            },
            async getStats() {
                const db = await initDB();
                return new Promise((resolve) => {
                    const tx = db.transaction(['cards', 'logs'], 'readonly');
                    const cardStore = tx.objectStore('cards');
                    const logStore = tx.objectStore('logs');
                    
                    const cardsRequest = cardStore.count();
                    const logsRequest = logStore.getAll();
                    
                    Promise.all([
                        new Promise(res => { cardsRequest.onsuccess = () => res(cardsRequest.result); }),
                        new Promise(res => { logsRequest.onsuccess = () => res(logsRequest.result); })
                    ]).then(([totalCards, logs]) => {
                        const today = new Date().toDateString();
                        const todayLogs = logs.filter(log => 
                            new Date(log.time).toDateString() === today
                        );
                        
                        const stats = {
                            totalCards,
                            reviewsToday: todayLogs.length,
                            retentionRate: logs.length > 0 
                                ? Math.round((logs.filter(l => l.rating >= 3).length / logs.length) * 100)
                                : 0
                        };
                        
                        resolve(stats);
                    });
                });
            }
        };

        // ==========================================
        // COMPONENTS
        // ==========================================

        const Toast = ({ message, type = 'info', onClose }) => {
            React.useEffect(() => {
                const timer = setTimeout(() => {
                    onClose();
                }, 3000);
                return () => clearTimeout(timer);
            }, [onClose]);

            const bgColor = {
                success: 'bg-green-500',
                error: 'bg-red-500',
                info: 'bg-blue-500',
                warning: 'bg-yellow-500'
            }[type];

            return React.createElement('div', {
                className: `fixed top-4 right-4 z-50 ${bgColor} text-white px-4 py-3 rounded-lg shadow-lg animate-slide-up`,
                role: 'alert'
            },
                React.createElement('div', { className: 'flex items-center' },
                    React.createElement('span', { className: 'mr-2' },
                        type === 'success' ? '✓' :
                        type === 'error' ? '✗' :
                        type === 'warning' ? '⚠' : 'ℹ'
                    ),
                    React.createElement('span', { className: 'font-medium' }, message)
                )
            );
        };

        const Spinner = ({ size = 'medium', className = '' }) => {
            const sizeClass = {
                small: 'w-4 h-4',
                medium: 'w-8 h-8',
                large: 'w-12 h-12'
            }[size];

            return React.createElement('div', {
                className: `${sizeClass} border-2 border-ios.blue border-t-transparent rounded-full animate-spin ${className}`
            });
        };

        const Layout = ({ children, activeTab, onTabChange, isDarkMode, toggleTheme }) => {
            return React.createElement('div', {
                className: 'flex flex-col h-screen bg-ios.bg dark:bg-black text-gray-900 dark:text-white select-none transition-colors duration-300'
            },
                React.createElement('header', {
                    className: 'h-[50px] bg-white/85 dark:bg-ios.darkCard/85 backdrop-blur-xl border-b border-gray-300/50 dark:border-gray-800/50 flex items-center justify-between px-4 sticky top-0 z-50 shadow-sm'
                },
                    React.createElement('div', { className: 'w-20' }),
                    React.createElement('div', { className: 'flex flex-col items-center' },
                        React.createElement('h1', { className: 'text-[17px] font-semibold text-black dark:text-white leading-tight' }, 'Anki'),
                        React.createElement('span', { className: 'text-[10px] text-gray-400 font-medium tracking-wide scale-90' }, '©️MUHAMMAD DALER')
                    ),
                    React.createElement('div', { className: 'w-20 flex justify-end' },
                        React.createElement('button', {
                            onClick: toggleTheme,
                            className: 'w-8 h-8 flex items-center justify-center rounded-full bg-gray-100 dark:bg-gray-800 text-gray-600 dark:text-yellow-400 hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors',
                            'aria-label': 'Toggle theme'
                        },
                            React.createElement('i', { className: `fa-solid ${isDarkMode ? 'fa-sun' : 'fa-moon'} text-sm` })
                        )
                    )
                ),

                React.createElement('main', {
                    className: 'flex-1 overflow-y-auto overflow-x-hidden relative scroll-smooth bg-ios.bg dark:bg-black'
                },
                    React.createElement('div', { className: 'max-w-3xl mx-auto h-full p-4 md:p-6' }, children)
                ),

                React.createElement('nav', {
                    className: 'h-[83px] bg-white/90 dark:bg-ios.darkCard/90 backdrop-blur-2xl border-t border-gray-300/50 dark:border-gray-800/50 flex justify-around items-start pt-2 pb-safe'
                },
                    ['decks', 'add', 'stats'].map(tab => 
                        React.createElement('button', {
                            key: tab,
                            onClick: () => onTabChange(tab),
                            className: `flex flex-col items-center justify-center w-20 space-y-1 transition-all active:scale-95 ${activeTab === tab ? 'text-ios.blue' : 'text-gray-400 dark:text-gray-500'}`,
                            'aria-label': `${tab} tab`
                        },
                            React.createElement('i', {
                                className: `fa-solid ${
                                    tab === 'decks' ? 'fa-layer-group' :
                                    tab === 'add' ? 'fa-plus-circle' : 'fa-chart-simple'
                                } text-[24px] ${activeTab === tab ? 'opacity-100' : 'opacity-70'}`
                            }),
                            React.createElement('span', { className: 'text-[10px] font-medium capitalize' }, tab)
                        )
                    )
                )
            );
        };

        const DeckList = ({ onSelectDeck }) => {
            const [decks, setDecks] = useState([]);
            const [isCreating, setIsCreating] = useState(false);
            const [newDeckName, setNewDeckName] = useState('');
            const [loading, setLoading] = useState(true);
            const [deckToDelete, setDeckToDelete] = useState(null);
            const [toast, setToast] = useState(null);

            useEffect(() => { 
                loadDecks(); 
            }, []);

            const loadDecks = async () => {
                try {
                    setLoading(true);
                    const loaded = await dbService.getAllDecks();
                    setDecks(loaded);
                } catch (e) { 
                    setToast({ message: 'Failed to load decks', type: 'error' });
                    console.error(e); 
                } finally { 
                    setLoading(false); 
                }
            };

            const handleCreateDeck = async (e) => {
                e.preventDefault();
                if (!newDeckName.trim()) {
                    setToast({ message: 'Deck name cannot be empty', type: 'error' });
                    return;
                }
                try {
                    await dbService.addDeck(newDeckName);
                    setNewDeckName('');
                    setIsCreating(false);
                    setToast({ message: 'Deck created successfully', type: 'success' });
                    loadDecks();
                } catch (err) { 
                    setToast({ message: 'Error creating deck', type: 'error' });
                }
            };

            const confirmDelete = async () => {
                if (!deckToDelete) return;
                try {
                    await dbService.deleteDeck(deckToDelete);
                    setToast({ message: 'Deck deleted successfully', type: 'success' });
                    setDeckToDelete(null);
                    loadDecks();
                } catch (error) {
                    setToast({ message: 'Failed to delete deck', type: 'error' });
                }
            };

            return React.createElement(React.Fragment, null,
                toast && React.createElement(Toast, {
                    message: toast.message,
                    type: toast.type,
                    onClose: () => setToast(null)
                }),

                React.createElement('div', { className: 'space-y-6 animate-fade-in-up pb-20 relative' },
                    React.createElement('div', { className: 'flex justify-between items-end px-2 mb-4' },
                        React.createElement('div', null,
                            React.createElement('h2', { className: 'text-3xl font-bold text-gray-900 dark:text-white tracking-tight' }, 'Library'),
                            React.createElement('p', { className: 'text-sm text-gray-400 font-medium mt-1' }, `${decks.length} Decks`)
                        ),
                        React.createElement('button', {
                            onClick: () => setIsCreating(true),
                            className: 'bg-ios.blue text-white w-8 h-8 rounded-full flex items-center justify-center shadow-md active:scale-90 transition-transform hover:bg-[#0062CC]',
                            'aria-label': 'Create new deck'
                        },
                            React.createElement('i', { className: 'fa-solid fa-plus text-sm' })
                        )
                    ),

                    isCreating && React.createElement('form', {
                        onSubmit: handleCreateDeck,
                        className: 'bg-white dark:bg-ios.darkCard p-4 rounded-2xl shadow-sm border border-gray-200 dark:border-gray-800 mb-6 flex flex-col gap-3 animate-scale-up'
                    },
                        React.createElement('input', {
                            type: 'text',
                            value: newDeckName,
                            onChange: (e) => setNewDeckName(e.target.value),
                            placeholder: 'Name your new deck',
                            autoFocus: true,
                            className: 'w-full bg-ios.bg dark:bg-[#2C2C2E] border-none rounded-xl px-4 py-3 text-[15px] text-gray-900 dark:text-white focus:ring-2 focus:ring-ios.blue placeholder-gray-400 dark:placeholder-gray-600',
                            maxLength: 100
                        }),
                        React.createElement('div', { className: 'flex gap-3' },
                            React.createElement('button', {
                                type: 'submit',
                                className: 'flex-1 bg-ios.blue text-white py-2.5 rounded-xl text-sm font-semibold hover:bg-[#0062CC] transition-colors'
                            }, 'Create Deck'),
                            React.createElement('button', {
                                type: 'button',
                                onClick: () => setIsCreating(false),
                                className: 'flex-1 bg-gray-100 dark:bg-gray-800 text-gray-600 dark:text-gray-300 py-2.5 rounded-xl text-sm font-semibold hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors'
                            }, 'Cancel')
                        )
                    ),
                    
                    deckToDelete && React.createElement('div', {
                        className: 'fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/20 backdrop-blur-sm animate-fade-in'
                    },
                        React.createElement('div', {
                            className: 'bg-white dark:bg-ios.darkCard rounded-2xl shadow-2xl w-full max-w-xs overflow-hidden scale-100 animate-scale-up border border-gray-100 dark:border-gray-700'
                        },
                            React.createElement('div', { className: 'p-6 text-center' },
                                React.createElement('h3', { className: 'text-lg font-bold text-gray-900 dark:text-white mb-2' }, 'Delete Deck?'),
                                React.createElement('p', { className: 'text-[13px] leading-relaxed text-gray-500 dark:text-gray-400' }, 'This will permanently delete this deck and all its content. This action cannot be undone.')
                            ),
                            React.createElement('div', { className: 'flex border-t border-gray-200 dark:border-gray-800' },
                                React.createElement('button', {
                                    onClick: () => setDeckToDelete(null),
                                    className: 'flex-1 py-3.5 text-[17px] text-gray-600 dark:text-gray-400 font-medium active:bg-gray-50 dark:active:bg-[#2C2C2E] transition-colors'
                                }, 'Cancel'),
                                React.createElement('div', { className: 'w-px bg-gray-200 dark:bg-gray-800' }),
                                React.createElement('button', {
                                    onClick: confirmDelete,
                                    className: 'flex-1 py-3.5 text-[17px] text-ios.red font-bold active:bg-gray-50 dark:active:bg-[#2C2C2E] transition-colors'
                                }, 'Delete')
                            )
                        )
                    ),

                    loading ? React.createElement('div', { className: 'text-center py-10' },
                        React.createElement(Spinner, { size: 'medium' })
                    ) : decks.length === 0 ? React.createElement('div', {
                        className: 'flex flex-col items-center justify-center py-20 text-center px-6'
                    },
                        React.createElement('div', {
                            className: 'w-16 h-16 bg-gray-200 dark:bg-gray-800 rounded-full flex items-center justify-center mb-6'
                        },
                            React.createElement('i', { className: 'fa-solid fa-box-open text-3xl text-gray-400 dark:text-gray-500' })
                        ),
                        React.createElement('h3', { className: 'text-lg font-semibold text-gray-900 dark:text-white mb-2' }, 'No Decks Yet'),
                        React.createElement('p', { className: 'text-gray-500 dark:text-gray-400 text-sm max-w-xs' }, 'Tap the + button above to create your first deck.')
                    ) : React.createElement('div', { className: 'grid grid-cols-1 gap-4' },
                        decks.map((deck) => React.createElement('div', {
                            key: deck.id,
                            onClick: () => onSelectDeck(deck.id),
                            className: 'group bg-white dark:bg-ios.darkCard p-5 rounded-[18px] shadow-sm border border-gray-100 dark:border-gray-800 active:scale-[0.98] transition-all cursor-pointer relative'
                        },
                            React.createElement('div', { className: 'flex items-center justify-between' },
                                React.createElement('div', { className: 'flex items-center gap-4' },
                                    React.createElement('div', {
                                        className: 'w-12 h-12 bg-blue-50 dark:bg-blue-900/30 rounded-xl flex items-center justify-center text-ios.blue'
                                    },
                                        React.createElement('i', { className: 'fa-solid fa-layer-group text-lg' })
                                    ),
                                    React.createElement('div', null,
                                        React.createElement('h3', {
                                            className: 'text-[17px] font-semibold text-gray-900 dark:text-white leading-tight'
                                        }, deck.name),
                                        React.createElement('span', {
                                            className: 'text-xs text-gray-400 font-medium'
                                        }, `${deck.cardCount || 0} cards`)
                                    )
                                ),
                                React.createElement('i', { className: 'fa-solid fa-chevron-right text-gray-300 dark:text-gray-600 text-xs' })
                            ),
                            React.createElement('button', {
                                onClick: (e) => { e.stopPropagation(); setDeckToDelete(deck.id); },
                                className: 'absolute top-4 right-4 opacity-0 group-hover:opacity-100 transition-opacity text-gray-400 hover:text-ios.red dark:hover:text-red-400',
                                'aria-label': 'Delete deck'
                            },
                                React.createElement('i', { className: 'fa-solid fa-trash-can text-sm' })
                            )
                        ))
                    )
                )
            );
        };

        const AddCardForm = () => {
            const [decks, setDecks] = useState([]);
            const [selectedDeckId, setSelectedDeckId] = useState('');
            const [type, setType] = useState('basic');
            const [front, setFront] = useState('');
            const [back, setBack] = useState('');
            const [loading, setLoading] = useState(true);
            const [toast, setToast] = useState(null);
            const frontInputRef = useRef(null);

            useEffect(() => {
                dbService.getAllDecks().then(data => {
                    setDecks(data);
                    if (data.length > 0) setSelectedDeckId(data[0].id);
                    setLoading(false);
                }).catch(err => {
                    setToast({ message: 'Failed to load decks', type: 'error' });
                    setLoading(false);
                });
            }, []);

            const insertCloze = () => {
                if (!frontInputRef.current) return;
                const textarea = frontInputRef.current;
                const start = textarea.selectionStart;
                const end = textarea.selectionEnd;
                const text = textarea.value;
                const selection = text.substring(start, end);
                const indices = getClozeIndices(text);
                const nextNum = indices.length > 0 ? Math.max(...indices) + 1 : 1;
                let replacement = '';
                let newCursorPos = 0;

                if (!selection) {
                    replacement = `{{c${nextNum}::...}}`;
                    newCursorPos = start + 3 + nextNum.toString().length + 2;
                } else {
                    replacement = `{{c${nextNum}::${selection}}}`;
                    newCursorPos = start + replacement.length;
                }
                const newText = text.substring(0, start) + replacement + text.substring(end);
                setFront(newText);
                setTimeout(() => { 
                    textarea.focus(); 
                    textarea.setSelectionRange(newCursorPos, newCursorPos); 
                }, 0);
            };

            const handleSubmit = async (e) => {
                e.preventDefault();
                if (!selectedDeckId) { 
                    setToast({ message: 'Select a deck.', type: 'error' }); 
                    return; 
                }
                if (!front.trim()) { 
                    setToast({ message: 'Front content is required.', type: 'error' }); 
                    return; 
                }

                try {
                    const noteId = crypto.randomUUID();
                    const now = Date.now();
                    const newNote = { 
                        id: noteId, 
                        deckId: selectedDeckId, 
                        type, 
                        fields: { front, back }, 
                        created: now 
                    };
                    const cards = [];
                    const safeFront = SecurityUtils.sanitizeHTML(front.replace(/\n/g, '<br>'));
                    const safeBack = SecurityUtils.sanitizeHTML(back.replace(/\n/g, '<br>'));

                    if (type === 'basic') {
                        cards.push({ 
                            id: crypto.randomUUID(), 
                            noteId, 
                            deckId: selectedDeckId, 
                            ord: 0, 
                            queue: 'new', 
                            due: now, 
                            interval: 0, 
                            ease: STARTING_EASE, 
                            reps: 0, 
                            lapses: 0, 
                            front: safeFront, 
                            back: safeBack,
                            created: now
                        });
                    } else if (type === 'cloze') {
                        const indices = getClozeIndices(front);
                        if (indices.length === 0) { 
                            setToast({ message: 'No cloze deletions ({{c1::..}}) found.', type: 'error' }); 
                            return; 
                        }
                        indices.forEach(index => {
                            const content = generateClozeContent(safeFront, index);
                            cards.push({
                                id: crypto.randomUUID(),
                                noteId,
                                deckId: selectedDeckId,
                                ord: index,
                                queue: 'new',
                                due: now,
                                interval: 0,
                                ease: STARTING_EASE,
                                reps: 0,
                                lapses: 0,
                                front: content.front,
                                back: `${content.back}${safeBack ? `<br/><br/><div class="mt-4 pt-4 border-t border-gray-200 dark:border-gray-700 text-sm text-gray-600 dark:text-gray-400">${safeBack}</div>` : ''}`,
                                created: now
                            });
                        });
                    }
                    await dbService.addNote(newNote, cards);
                    setToast({ message: `Card${cards.length > 1 ? 's' : ''} added successfully!`, type: 'success' });
                    setFront(''); 
                    setBack('');
                    setTimeout(() => setToast(null), 2000);
                } catch (err) { 
                    setToast({ message: 'Error saving card.', type: 'error' }); 
                }
            };

            return React.createElement(React.Fragment, null,
                toast && React.createElement(Toast, {
                    message: toast.message,
                    type: toast.type,
                    onClose: () => setToast(null)
                }),

                React.createElement('div', { className: 'max-w-xl mx-auto space-y-5 animate-fade-in-up pb-10' },
                    React.createElement('div', { className: 'flex items-center justify-between' },
                        React.createElement('h2', { className: 'text-2xl font-bold text-gray-900 dark:text-white tracking-tight' }, 'Add Card'),
                        loading && React.createElement(Spinner, { size: 'small' })
                    ),
                    React.createElement('form', {
                        onSubmit: handleSubmit,
                        className: 'bg-white dark:bg-ios.darkCard p-5 rounded-[22px] shadow-sm border border-gray-200/50 dark:border-gray-800 transition-colors'
                    },
                        React.createElement('div', { className: 'space-y-2' },
                            React.createElement('label', { className: 'text-[11px] font-bold text-gray-400 uppercase tracking-wide ml-1' }, 'Deck'),
                            React.createElement('div', { className: 'relative' },
                                React.createElement('select', {
                                    value: selectedDeckId,
                                    onChange: e => setSelectedDeckId(e.target.value),
                                    className: 'w-full appearance-none bg-ios.bg dark:bg-[#2C2C2E] border-0 text-gray-900 dark:text-white text-[15px] rounded-xl focus:ring-2 focus:ring-ios.blue block p-3.5 pr-8 font-medium transition-colors'
                                },
                                    decks.length === 0 && React.createElement('option', { value: '' }, 'Create a deck first...'),
                                    decks.map(d => React.createElement('option', { key: d.id, value: d.id }, d.name))
                                ),
                                React.createElement('div', { className: 'pointer-events-none absolute inset-y-0 right-0 flex items-center px-4 text-gray-500' },
                                    React.createElement('i', { className: 'fa-solid fa-chevron-down text-xs' })
                                )
                            )
                        ),
                        React.createElement('div', { className: 'space-y-2' },
                            React.createElement('label', { className: 'text-[11px] font-bold text-gray-400 uppercase tracking-wide ml-1' }, 'Card Type'),
                            React.createElement('div', { className: 'grid grid-cols-2 gap-2 bg-ios.bg dark:bg-[#2C2C2E] p-1 rounded-xl' },
                                React.createElement('button', {
                                    type: 'button',
                                    onClick: () => setType('basic'),
                                    className: `py-2.5 text-[13px] font-semibold rounded-[10px] transition-all duration-200 ${type === 'basic' ? 'bg-white dark:bg-[#3A3A3C] text-black dark:text-white shadow-sm scale-[1.02]' : 'text-gray-500 hover:text-gray-700 dark:hover:text-gray-300'}`
                                }, 'Basic'),
                                React.createElement('button', {
                                    type: 'button',
                                    onClick: () => setType('cloze'),
                                    className: `py-2.5 text-[13px] font-semibold rounded-[10px] transition-all duration-200 ${type === 'cloze' ? 'bg-white dark:bg-[#3A3A3C] text-black dark:text-white shadow-sm scale-[1.02]' : 'text-gray-500 hover:text-gray-700 dark:hover:text-gray-300'}`
                                }, 'Cloze')
                            )
                        ),
                        React.createElement('div', { className: 'space-y-2 relative' },
                            React.createElement('div', { className: 'flex justify-between items-center ml-1' },
                                React.createElement('label', { className: 'text-[11px] font-bold text-gray-400 uppercase tracking-wide' }, type === 'cloze' ? 'Text (Use {{c1::...}})' : 'Front'),
                                type === 'cloze' && React.createElement('button', {
                                    type: 'button',
                                    onClick: insertCloze,
                                    className: 'text-[11px] bg-blue-50 dark:bg-blue-500/10 text-ios.blue dark:text-blue-400 px-2.5 py-1 rounded-md font-bold hover:bg-blue-100 dark:hover:bg-blue-500/20 transition-colors border border-blue-100 dark:border-blue-500/20'
                                },
                                    React.createElement('i', { className: 'fa-solid fa-code mr-1' }),
                                    'Insert Cloze'
                                )
                            ),
                            React.createElement('textarea', {
                                ref: frontInputRef,
                                value: front,
                                onChange: e => setFront(e.target.value),
                                rows: 6,
                                className: 'w-full bg-ios.bg dark:bg-[#2C2C2E] border-0 text-gray-900 dark:text-white text-[16px] leading-relaxed rounded-xl focus:ring-2 focus:ring-ios.blue block p-4 font-normal placeholder-gray-400 dark:placeholder-gray-600 resize-none transition-colors',
                                placeholder: type === 'cloze' ? "The {{c1::capital}} of France is {{c2::Paris}}." : "Question or main text"
                            })
                        ),
                        React.createElement('div', { className: 'space-y-2' },
                            React.createElement('label', { className: 'text-[11px] font-bold text-gray-400 uppercase tracking-wide ml-1' }, 'Back (Extra)'),
                            React.createElement('textarea', {
                                value: back,
                                onChange: e => setBack(e.target.value),
                                rows: 3,
                                className: 'w-full bg-ios.bg dark:bg-[#2C2C2E] border-0 text-gray-900 dark:text-white text-[16px] leading-relaxed rounded-xl focus:ring-2 focus:ring-ios.blue block p-4 font-normal placeholder-gray-400 dark:placeholder-gray-600 resize-none transition-colors',
                                placeholder: 'Extra info...'
                            })
                        ),
                        React.createElement('button', {
                            type: 'submit',
                            className: 'w-full bg-ios.blue hover:bg-[#0062cc] active:scale-[0.98] text-white font-semibold text-[15px] py-4 rounded-xl shadow-lg shadow-blue-500/25 transition-all duration-200 mt-2'
                        }, 'Add Card')
                    ),
                    React.createElement('p', { className: 'text-center text-[10px] text-gray-400 dark:text-gray-600 px-4' },
                        'Tip: In Cloze mode, type ',
                        React.createElement('code', { className: 'bg-gray-100 dark:bg-gray-800 px-1 rounded' }, '{{c1::answer::hint}}'),
                        ' for hints.'
                    )
                )
            );
        };

        const StudySession = ({ deckId, onExit }) => {
            const [cards, setCards] = useState([]);
            const [currentIndex, setCurrentIndex] = useState(0);
            const [isFlipped, setIsFlipped] = useState(false);
            const [loading, setLoading] = useState(true);
            const [toast, setToast] = useState(null);

            useEffect(() => {
                let mounted = true;
                const load = async () => {
                    try {
                        const due = await dbService.getDueCards(deckId);
                        if (mounted) { 
                            setCards(due); 
                            setLoading(false); 
                        }
                    } catch (err) { 
                        if (mounted) {
                            setToast({ message: 'Failed to load cards', type: 'error' });
                            setLoading(false); 
                        }
                    }
                };
                load();
                return () => { mounted = false; };
            }, [deckId]);

            const currentCard = cards[currentIndex];

            const handleRate = async (rating) => {
                if (!currentCard) return;
                setIsFlipped(false);
                setTimeout(async () => {
                    try {
                        const { card: updatedCard, log } = scheduleCard(currentCard, rating);
                        await dbService.updateCard(updatedCard, log);
                        const newCards = cards.filter((_, idx) => idx !== currentIndex);
                        setCards(newCards);
                        if (newCards.length > 0) {
                            setCurrentIndex(Math.min(currentIndex, newCards.length - 1));
                        }
                    } catch (error) {
                        setToast({ message: 'Failed to update card', type: 'error' });
                    }
                }, 200);
            };

            const handleClozeClick = (e) => {
                if (e.target.classList.contains('cloze-hidden')) {
                    e.target.classList.remove('cloze-hidden');
                    e.target.classList.add('cloze-revealed');
                    e.target.textContent = 'Revealed';
                }
            };

            if (loading) return React.createElement('div', {
                className: 'h-full flex flex-col items-center justify-center text-gray-400 dark:text-gray-500'
            },
                React.createElement(Spinner, { size: 'medium', className: 'mb-4' }),
                React.createElement('span', { className: 'text-sm font-medium' }, 'Loading cards...')
            );
            
            if (!currentCard) return React.createElement('div', {
                className: 'h-full flex flex-col items-center justify-center text-center p-6 space-y-6 animate-fade-in'
            },
                React.createElement('div', {
                    className: 'w-24 h-24 bg-gradient-to-br from-green-400 to-green-500 rounded-full flex items-center justify-center shadow-lg shadow-green-500/30'
                },
                    React.createElement('i', { className: 'fa-solid fa-check text-4xl text-white' })
                ),
                React.createElement('div', null,
                    React.createElement('h2', { className: 'text-2xl font-bold text-gray-900 dark:text-white mb-2' }, 'You\'re all done!'),
                    React.createElement('p', { className: 'text-gray-500 dark:text-gray-400 max-w-xs mx-auto' }, 'No more cards due for today.')
                ),
                React.createElement('button', {
                    onClick: onExit,
                    className: 'mt-8 bg-ios.blue active:bg-[#0056CC] text-white px-8 py-3.5 rounded-xl font-semibold shadow-lg shadow-blue-500/20 transition-all transform active:scale-95'
                }, 'Back to Decks')
            );

            return React.createElement(React.Fragment, null,
                toast && React.createElement(Toast, {
                    message: toast.message,
                    type: toast.type,
                    onClose: () => setToast(null)
                }),

                React.createElement('div', { className: 'h-full flex flex-col' },
                    React.createElement('div', { className: 'flex justify-between items-center mb-4 px-1' },
                        React.createElement('button', {
                            onClick: onExit,
                            className: 'text-xs font-semibold text-gray-400 uppercase tracking-wider hover:text-gray-600 dark:hover:text-gray-300 flex items-center'
                        },
                            React.createElement('i', { className: 'fa-solid fa-chevron-left mr-1' }),
                            'Library'
                        ),
                        React.createElement('div', { className: 'bg-gray-200 dark:bg-gray-800 text-gray-600 dark:text-gray-300 text-[10px] font-bold px-2 py-1 rounded-full' }, `${cards.length} REMAINING`)
                    ),
                    React.createElement('div', {
                        className: `card-container flex-1 relative cursor-pointer mb-6 ${isFlipped ? 'card-flipped' : ''}`,
                        onClick: () => !isFlipped && setIsFlipped(true)
                    },
                        React.createElement('div', {
                            className: 'card-inner w-full h-full shadow-[0_8px_30px_rgba(0,0,0,0.12)] dark:shadow-[0_8px_30px_rgba(0,0,0,0.3)] rounded-[20px] bg-transparent'
                        },
                            React.createElement('div', {
                                className: 'card-front flex flex-col items-center justify-center p-8 text-center bg-white dark:bg-ios.darkCard border border-gray-100 dark:border-gray-800 rounded-[20px]',
                                onClick: handleClozeClick,
                                dangerouslySetInnerHTML: { __html: currentCard.front }
                            }),
                            React.createElement('div', {
                                className: 'card-back flex flex-col items-center justify-center p-8 text-center bg-white dark:bg-ios.darkCard border border-gray-100 dark:border-gray-800 rounded-[20px] overflow-y-auto',
                                onClick: handleClozeClick,
                                dangerouslySetInnerHTML: { __html: currentCard.back }
                            })
                        )
                    ),
                    React.createElement('div', {
                        className: `grid grid-cols-4 gap-3 transition-all duration-300 ${isFlipped ? 'opacity-100 translate-y-0' : 'opacity-0 translate-y-4 pointer-events-none'}`
                    },
                        React.createElement('button', {
                            onClick: (e) => { e.stopPropagation(); handleRate(1); },
                            className: 'group flex flex-col items-center justify-center p-3 rounded-xl bg-white dark:bg-ios.darkCard border border-gray-200 dark:border-gray-800 active:bg-gray-50 dark:active:bg-[#2C2C2E] shadow-sm transition-all'
                        },
                            React.createElement('span', { className: 'text-[15px] font-semibold text-ios.red mb-1' }, 'Again'),
                            React.createElement('span', { className: 'text-[10px] text-gray-400 dark:text-gray-500 font-medium group-active:text-gray-600' }, '1m')
                        ),
                        React.createElement('button', {
                            onClick: (e) => { e.stopPropagation(); handleRate(2); },
                            className: 'group flex flex-col items-center justify-center p-3 rounded-xl bg-white dark:bg-ios.darkCard border border-gray-200 dark:border-gray-800 active:bg-gray-50 dark:active:bg-[#2C2C2E] shadow-sm transition-all'
                        },
                            React.createElement('span', { className: 'text-[15px] font-semibold text-ios.yellow mb-1' }, 'Hard'),
                            React.createElement('span', { className: 'text-[10px] text-gray-400 dark:text-gray-500 font-medium group-active:text-gray-600' }, '10m')
                        ),
                        React.createElement('button', {
                            onClick: (e) => { e.stopPropagation(); handleRate(3); },
                            className: 'group flex flex-col items-center justify-center p-3 rounded-xl bg-white dark:bg-ios.darkCard border border-gray-200 dark:border-gray-800 active:bg-gray-50 dark:active:bg-[#2C2C2E] shadow-sm transition-all'
                        },
                            React.createElement('span', { className: 'text-[15px] font-semibold text-ios.green mb-1' }, 'Good'),
                            React.createElement('span', { className: 'text-[10px] text-gray-400 dark:text-gray-500 font-medium group-active:text-gray-600' }, '1d')
                        ),
                        React.createElement('button', {
                            onClick: (e) => { e.stopPropagation(); handleRate(4); },
                            className: 'group flex flex-col items-center justify-center p-3 rounded-xl bg-white dark:bg-ios.darkCard border border-gray-200 dark:border-gray-800 active:bg-gray-50 dark:active:bg-[#2C2C2E] shadow-sm transition-all'
                        },
                            React.createElement('span', { className: 'text-[15px] font-semibold text-ios.blue mb-1' }, 'Easy'),
                            React.createElement('span', { className: 'text-[10px] text-gray-400 dark:text-gray-500 font-medium group-active:text-gray-600' }, '4d')
                        )
                    )
                )
            );
        };

        const Stats = () => {
            const [stats, setStats] = useState({
                totalCards: 0,
                reviewsToday: 0,
                retentionRate: 0
            });
            const [loading, setLoading] = useState(true);

            useEffect(() => {
                loadStats();
            }, []);

            const loadStats = async () => {
                try {
                    setLoading(true);
                    const statsData = await dbService.getStats();
                    setStats(statsData);
                } catch (error) {
                    console.error('Failed to load stats:', error);
                } finally {
                    setLoading(false);
                }
            };

            return React.createElement('div', { className: 'space-y-6 animate-fade-in-up' },
                React.createElement('h2', { className: 'text-2xl font-bold text-gray-900 dark:text-white tracking-tight text-center' }, 'Statistics'),
                loading ? React.createElement('div', { className: 'text-center py-10' },
                    React.createElement(Spinner, { size: 'medium' })
                ) : React.createElement(React.Fragment, null,
                    React.createElement('div', { className: 'grid grid-cols-2 gap-4' },
                        React.createElement('div', { className: 'bg-white dark:bg-ios.darkCard p-6 rounded-2xl shadow-sm border border-gray-200 dark:border-gray-800 flex flex-col items-center transition-colors' },
                            React.createElement('span', { className: 'text-4xl font-bold text-ios.blue mb-2' }, stats.totalCards),
                            React.createElement('span', { className: 'text-xs text-gray-400 uppercase font-semibold' }, 'Total Cards')
                        ),
                        React.createElement('div', { className: 'bg-white dark:bg-ios.darkCard p-6 rounded-2xl shadow-sm border border-gray-200 dark:border-gray-800 flex flex-col items-center transition-colors' },
                            React.createElement('span', { className: 'text-4xl font-bold text-ios.green mb-2' }, `${stats.retentionRate}%`),
                            React.createElement('span', { className: 'text-xs text-gray-400 uppercase font-semibold' }, 'Retention Rate')
                        )
                    ),
                    React.createElement('div', { className: 'bg-white dark:bg-ios.darkCard p-6 rounded-2xl shadow-sm border border-gray-200 dark:border-gray-800 flex flex-col items-center transition-colors' },
                        React.createElement('span', { className: 'text-4xl font-bold text-ios.yellow mb-2' }, stats.reviewsToday),
                        React.createElement('span', { className: 'text-xs text-gray-400 uppercase font-semibold' }, 'Reviews Today')
                    ),
                    React.createElement('div', { className: 'bg-white dark:bg-ios.darkCard p-8 rounded-2xl shadow-sm border border-gray-200 dark:border-gray-800 text-center transition-colors' },
                        React.createElement('div', { className: 'text-gray-300 dark:text-gray-600 mb-4' },
                            React.createElement('i', { className: 'fa-solid fa-chart-line text-5xl' })
                        ),
                        React.createElement('h3', { className: 'text-gray-900 dark:text-white font-medium mb-1' }, 'Study Streak: 0 days'),
                        React.createElement('p', { className: 'text-sm text-gray-500 dark:text-gray-400' }, 'Study every day to build your streak!')
                    )
                )
            );
        };

        const App = () => {
            const [activeTab, setActiveTab] = useState('decks');
            const [selectedDeckId, setSelectedDeckId] = useState(null);
            const [isDarkMode, setIsDarkMode] = useState(() => {
                if (typeof window !== 'undefined' && window.localStorage) {
                    const s = localStorage.getItem('anki-theme');
                    if (s) return s === 'dark';
                }
                return window.matchMedia('(prefers-color-scheme: dark)').matches;
            });

            useEffect(() => {
                localStorage.setItem('anki-theme', isDarkMode ? 'dark' : 'light');
                if (isDarkMode) {
                    document.documentElement.classList.add('dark');
                } else {
                    document.documentElement.classList.remove('dark');
                }
            }, [isDarkMode]);

            const renderContent = () => {
                if (selectedDeckId) return React.createElement(StudySession, {
                    deckId: selectedDeckId,
                    onExit: () => setSelectedDeckId(null)
                });
                switch (activeTab) {
                    case 'decks': return React.createElement(DeckList, { onSelectDeck: setSelectedDeckId });
                    case 'add': return React.createElement(AddCardForm);
                    case 'stats': return React.createElement(Stats);
                    default: return React.createElement(DeckList, { onSelectDeck: setSelectedDeckId });
                }
            };

            return React.createElement('div', { className: isDarkMode ? 'dark' : '' },
                React.createElement(Layout, {
                    activeTab: selectedDeckId ? 'decks' : activeTab,
                    onTabChange: (tab) => { 
                        setSelectedDeckId(null); 
                        setActiveTab(tab); 
                    },
                    isDarkMode: isDarkMode,
                    toggleTheme: () => setIsDarkMode(!isDarkMode)
                }, renderContent())
            );
        };

        ReactDOM.render(React.createElement(App), document.getElementById('root'));
    </script>
</body>
</html>