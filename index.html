<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anki iOS</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    
    <style>
        :root {
            --bg-primary: #000000;
            --bg-secondary: #1c1c1e;
            --text-primary: #ffffff;
            --text-secondary: #8e8e93;
            --accent: #0a84ff;
            --danger: #ff453a;
            --success: #32d74b;
            --warning: #ff9f0a;
            --card-bg: #2c2c2e;
            --separator: #38383a;
        }

        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            height: 100vh;
            overflow: hidden;
        }

        .view {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding-top: 60px;
            padding-bottom: 70px;
            overflow-y: auto;
            display: none;
            flex-direction: column;
        }

        .view.active {
            display: flex;
        }

        header {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 60px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--separator);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
            z-index: 50;
        }

        .tab-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 70px;
            background: var(--bg-secondary);
            border-top: 1px solid var(--separator);
            display: flex;
            justify-content: space-around;
            align-items: center;
            z-index: 50;
        }

        .tab-item {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            font-size: 10px;
            gap: 4px;
            cursor: pointer;
            padding: 8px 0;
        }

        .tab-item.active {
            color: var(--accent);
        }

        .tab-item i {
            font-size: 20px;
        }

        .deck-item {
            background-color: var(--bg-secondary);
            padding: 16px;
            margin: 8px 16px;
            border-radius: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .flashcard-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 16px;
            justify-content: center;
        }

        .flashcard {
            background: var(--card-bg);
            border-radius: 16px;
            min-height: 300px;
            padding: 24px;
            font-size: 20px;
            line-height: 1.5;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            cursor: pointer;
            user-select: none;
        }

        .review-controls {
            position: fixed;
            bottom: 80px;
            left: 0;
            width: 100%;
            padding: 0 16px;
            display: flex;
            gap: 8px;
            z-index: 40;
        }

        .btn-answer {
            flex: 1;
            padding: 12px 0;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
            color: white;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            border: none;
            cursor: pointer;
        }

        .btn-again { background-color: var(--danger); }
        .btn-hard { background-color: var(--warning); }
        .btn-good { background-color: var(--success); }
        .btn-easy { background-color: var(--accent); }

        input, textarea, select {
            background: var(--bg-secondary);
            border: 1px solid var(--separator);
            color: var(--text-primary);
            border-radius: 8px;
            padding: 12px;
            width: 100%;
            margin-bottom: 12px;
            font-size: 16px;
        }
        
        .fab {
            position: fixed;
            bottom: 80px;
            right: 20px;
            width: 56px;
            height: 56px;
            border-radius: 28px;
            background: var(--accent);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            z-index: 45;
            cursor: pointer;
            border: none;
        }

        .cloze {
            color: var(--accent);
            font-weight: bold;
            background: rgba(10, 132, 255, 0.1);
            padding: 2px 4px;
            border-radius: 4px;
        }

        .cloze-blank {
            color: var(--accent);
            font-weight: bold;
            border-bottom: 2px dashed var(--accent);
            padding: 0 4px;
        }

        .hidden {
            display: none !important;
        }

        .stat-card {
            background: var(--card-bg);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            margin: 8px;
        }

        .card-content {
            width: 100%;
        }

        .cloze-hint {
            color: var(--accent);
            font-size: 14px;
            margin-top: 10px;
        }
    </style>
</head>
<body>

    <header>
        <h1 id="header-title" class="text-lg font-bold">Anki iOS</h1>
    </header>

    <!-- DECK LIST VIEW -->
    <div id="view-decks" class="view active">
        <div class="px-4 py-2">
            <h2 class="text-sm text-gray-500 uppercase font-bold mb-2">My Decks</h2>
            <div id="deck-list-container">
                <!-- Decks will be loaded here -->
            </div>
        </div>
        <button class="fab" id="add-deck-btn">
            <i class="fa-solid fa-plus"></i>
        </button>
    </div>

    <!-- REVIEW VIEW -->
    <div id="view-review" class="view">
        <div class="w-full flex justify-between px-4 py-2 text-sm text-gray-500">
            <span id="review-counts" class="font-mono">
                <span class="text-blue-400">0</span> 
                <span class="text-red-400">0</span> 
                <span class="text-green-400">0</span>
            </span>
            <span id="timer">0s</span>
        </div>

        <div class="flashcard-container">
            <div class="flashcard" id="card-content">
                <div class="text-gray-500">Loading card...</div>
            </div>
        </div>

        <div id="ans-controls" class="review-controls hidden">
            <button class="btn-answer btn-again" data-rating="1">Again<br><small>1m</small></button>
            <button class="btn-answer btn-hard" data-rating="2">Hard<br><small>10m</small></button>
            <button class="btn-answer btn-good" data-rating="3">Good<br><small>1d</small></button>
            <button class="btn-answer btn-easy" data-rating="4">Easy<br><small>4d</small></button>
        </div>
        
        <div id="show-ans-control" class="review-controls">
            <button class="w-full bg-gray-700 text-white py-3 rounded-lg font-semibold" id="show-answer-btn">Show Answer</button>
        </div>
    </div>

    <!-- ADD/EDIT VIEW -->
    <div id="view-add" class="view">
        <div class="px-4">
            <label class="block text-sm text-gray-500 mb-1">Deck</label>
            <select id="add-deck-select">
                <option value="">Select a deck</option>
            </select>

            <label class="block text-sm text-gray-500 mb-1">Type</label>
            <select id="add-note-type">
                <option value="basic">Basic</option>
                <option value="basic-rev">Basic (and Reversed Card)</option>
                <option value="cloze">Cloze</option>
            </select>

            <div id="fields-container">
                <!-- Fields will be dynamically updated -->
            </div>
            
            <button class="w-full bg-blue-600 text-white py-3 rounded-lg font-bold mt-4" id="save-note-btn">Add Card</button>
        </div>
    </div>

    <!-- BROWSER VIEW -->
    <div id="view-browse" class="view">
        <div class="px-4 mb-2">
            <input type="text" id="search-input" placeholder="Search cards..." class="w-full">
        </div>
        <div id="browser-list" class="divide-y divide-gray-800"></div>
    </div>

    <!-- STATS VIEW -->
    <div id="view-stats" class="view">
        <div class="px-4 py-4">
            <h2 class="text-2xl font-bold mb-4 text-center">Statistics</h2>
            <div class="grid grid-cols-2 gap-4">
                <div class="stat-card">
                    <div class="text-3xl font-bold text-blue-500" id="stat-total">0</div>
                    <div class="text-xs text-gray-400">Total Cards</div>
                </div>
                <div class="stat-card">
                    <div class="text-3xl font-bold text-green-500" id="stat-due">0</div>
                    <div class="text-xs text-gray-400">Due Today</div>
                </div>
                <div class="stat-card">
                    <div class="text-3xl font-bold text-yellow-500" id="stat-learn">0</div>
                    <div class="text-xs text-gray-400">Learning</div>
                </div>
                <div class="stat-card">
                    <div class="text-3xl font-bold text-purple-500" id="stat-review">0</div>
                    <div class="text-xs text-gray-400">To Review</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Tab Bar -->
    <div class="tab-bar">
        <div class="tab-item active" data-view="decks">
            <i class="fa-solid fa-layer-group"></i>
            <span>Decks</span>
        </div>
        <div class="tab-item" data-view="add">
            <i class="fa-solid fa-plus-circle"></i>
            <span>Add</span>
        </div>
        <div class="tab-item" data-view="browse">
            <i class="fa-solid fa-magnifying-glass"></i>
            <span>Browse</span>
        </div>
        <div class="tab-item" data-view="stats">
            <i class="fa-solid fa-chart-simple"></i>
            <span>Stats</span>
        </div>
    </div>

    <script>
    class AnkiApp {
        constructor() {
            this.db = null;
            this.currentDeck = null;
            this.studyQueue = [];
            this.currentCard = null;
            this.currentNote = null;
            this.isShowingBack = false;
            this.startTime = null;
            this.timerInterval = null;
            this.decks = [];
            this.notes = [];
            this.cards = [];
            
            this.init();
        }

        async init() {
            await this.initDB();
            await this.loadData();
            this.setupEventListeners();
            this.updateFields();
            this.renderDeckList();
            
            // Set default deck if exists
            if (this.decks.length > 0) {
                document.getElementById('add-deck-select').value = this.decks[0].id;
            }
        }

        initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('AnkiDB', 1);
                
                request.onerror = (event) => {
                    console.error("Database error:", event.target.error);
                    reject(event.target.error);
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    
                    // Create decks store
                    if (!db.objectStoreNames.contains('decks')) {
                        const deckStore = db.createObjectStore('decks', { keyPath: 'id' });
                        deckStore.createIndex('name', 'name', { unique: false });
                    }
                    
                    // Create notes store
                    if (!db.objectStoreNames.contains('notes')) {
                        const noteStore = db.createObjectStore('notes', { keyPath: 'id' });
                        noteStore.createIndex('deckId', 'deckId', { unique: false });
                    }
                    
                    // Create cards store
                    if (!db.objectStoreNames.contains('cards')) {
                        const cardStore = db.createObjectStore('cards', { keyPath: 'id' });
                        cardStore.createIndex('noteId', 'noteId', { unique: false });
                        cardStore.createIndex('deckId', 'deckId', { unique: false });
                        cardStore.createIndex('due', 'due', { unique: false });
                    }
                };
                
                request.onsuccess = (event) => {
                    this.db = event.target.result;
                    resolve();
                };
            });
        }

        async loadData() {
            this.decks = await this.getAll('decks');
            this.notes = await this.getAll('notes');
            this.cards = await this.getAll('cards');
            
            // If no decks, create default
            if (this.decks.length === 0) {
                await this.add('decks', {
                    id: Date.now(),
                    name: 'Default',
                    created: Date.now()
                });
                this.decks = await this.getAll('decks');
            }
        }

        // Database helper methods
        getAll(storeName) {
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.getAll();
                
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        add(storeName, data) {
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.add(data);
                
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        put(storeName, data) {
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.put(data);
                
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        delete(storeName, id) {
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.delete(id);
                
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        // Navigation
        navigate(view) {
            // Hide all views
            document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
            // Show selected view
            document.getElementById(`view-${view}`).classList.add('active');
            
            // Update tabs
            document.querySelectorAll('.tab-item').forEach(tab => tab.classList.remove('active'));
            document.querySelector(`.tab-item[data-view="${view}"]`).classList.add('active');
            
            // Update header
            const titles = {
                'decks': 'My Decks',
                'add': 'Add Card',
                'browse': 'Browse',
                'stats': 'Statistics',
                'review': 'Study'
            };
            document.getElementById('header-title').textContent = titles[view] || 'Anki iOS';
            
            // Refresh view data
            if (view === 'decks') this.renderDeckList();
            else if (view === 'stats') this.renderStats();
            else if (view === 'browse') this.renderBrowser();
        }

        setupEventListeners() {
            // Tab navigation
            document.querySelectorAll('.tab-item').forEach(tab => {
                tab.addEventListener('click', (e) => {
                    const view = e.currentTarget.dataset.view;
                    this.navigate(view);
                });
            });

            // Add deck button
            document.getElementById('add-deck-btn').addEventListener('click', () => {
                const name = prompt('Enter deck name:');
                if (name && name.trim()) {
                    this.createDeck(name.trim());
                }
            });

            // Note type change
            document.getElementById('add-note-type').addEventListener('change', () => {
                this.updateFields();
            });

            // Save note button
            document.getElementById('save-note-btn').addEventListener('click', () => {
                this.saveNote();
            });

            // Show answer button
            document.getElementById('show-answer-btn').addEventListener('click', () => {
                this.showAnswer();
            });

            // Answer buttons
            document.querySelectorAll('.btn-answer').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const rating = parseInt(e.currentTarget.dataset.rating);
                    this.answerCard(rating);
                });
            });

            // Search input
            document.getElementById('search-input').addEventListener('input', (e) => {
                this.renderBrowser(e.target.value);
            });

            // Card click to flip
            document.getElementById('card-content').addEventListener('click', () => {
                if (this.currentCard && !this.isShowingBack) {
                    this.showAnswer();
                }
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (!this.isShowingBack && e.code === 'Space') {
                    this.showAnswer();
                    e.preventDefault();
                } else if (this.isShowingBack) {
                    switch(e.code) {
                        case 'Digit1': this.answerCard(1); break;
                        case 'Digit2': this.answerCard(2); break;
                        case 'Digit3': this.answerCard(3); break;
                        case 'Digit4': this.answerCard(4); break;
                    }
                }
            });
        }

        updateFields() {
            const type = document.getElementById('add-note-type').value;
            const container = document.getElementById('fields-container');
            
            if (type === 'cloze') {
                container.innerHTML = `
                    <label class="block text-sm text-gray-500 mb-1">Text (Use {{c1::cloze}} syntax)</label>
                    <textarea id="f-front" rows="6" placeholder="Example: The {{c1::capital}} of France is {{c2::Paris}}."></textarea>
                    <div class="cloze-hint">
                        <i class="fa-solid fa-lightbulb"></i> Use {{c1::text}} for cloze deletions. Multiple clozes: {{c1::first}}, {{c2::second}}, etc.
                    </div>
                    <label class="block text-sm text-gray-500 mb-1 mt-4">Extra Information (Optional)</label>
                    <textarea id="f-back" rows="3" placeholder="Additional notes or context"></textarea>
                `;
            } else {
                container.innerHTML = `
                    <label class="block text-sm text-gray-500 mb-1">Front</label>
                    <textarea id="f-front" rows="3" placeholder="Question or front side"></textarea>
                    <label class="block text-sm text-gray-500 mb-1">Back</label>
                    <textarea id="f-back" rows="3" placeholder="Answer or back side"></textarea>
                `;
            }
            
            // Populate deck select
            this.populateDeckSelect();
        }

        populateDeckSelect() {
            const select = document.getElementById('add-deck-select');
            select.innerHTML = '<option value="">Select a deck</option>';
            
            this.decks.forEach(deck => {
                const option = document.createElement('option');
                option.value = deck.id;
                option.textContent = deck.name;
                select.appendChild(option);
            });
        }

        async createDeck(name) {
            const deck = {
                id: Date.now(),
                name: name,
                created: Date.now()
            };
            
            await this.add('decks', deck);
            this.decks.push(deck);
            this.renderDeckList();
            this.populateDeckSelect();
        }

        renderDeckList() {
            const container = document.getElementById('deck-list-container');
            container.innerHTML = '';
            
            const now = Date.now();
            const today = Math.floor(now / 86400000); // Days since epoch
            
            this.decks.forEach(deck => {
                const deckCards = this.cards.filter(card => card.deckId === deck.id);
                
                const newCount = deckCards.filter(card => card.type === 0).length;
                const learnCount = deckCards.filter(card => 
                    (card.type === 1 || card.type === 3) && card.due < now / 1000
                ).length;
                const reviewCount = deckCards.filter(card => 
                    card.type === 2 && card.due <= today
                ).length;
                
                const deckElement = document.createElement('div');
                deckElement.className = 'deck-item';
                deckElement.innerHTML = `
                    <div class="flex-1">
                        <div class="font-semibold text-lg">${deck.name}</div>
                        <div class="text-sm text-gray-500">${deckCards.length} cards</div>
                    </div>
                    <div class="flex gap-3 text-sm font-mono">
                        <span class="text-blue-400 font-bold">${newCount}</span>
                        <span class="text-red-400 font-bold">${learnCount}</span>
                        <span class="text-green-400 font-bold">${reviewCount}</span>
                    </div>
                `;
                
                deckElement.addEventListener('click', () => this.startStudy(deck.id));
                container.appendChild(deckElement);
            });
        }

        async saveNote() {
            const deckId = parseInt(document.getElementById('add-deck-select').value);
            const type = document.getElementById('add-note-type').value;
            const front = document.getElementById('f-front').value.trim();
            const back = document.getElementById('f-back').value.trim();
            
            if (!deckId) {
                alert('Please select a deck');
                return;
            }
            
            if (!front) {
                alert('Front field cannot be empty');
                return;
            }
            
            const noteId = Date.now();
            
            // Save note
            const note = {
                id: noteId,
                deckId: deckId,
                type: type,
                front: front,
                back: back,
                created: Date.now()
            };
            
            await this.add('notes', note);
            this.notes.push(note);
            
            // Create cards based on type
            if (type === 'basic') {
                const card = {
                    id: noteId * 10,
                    noteId: noteId,
                    deckId: deckId,
                    type: 0, // new
                    due: 0,
                    interval: 0,
                    ease: 2.5,
                    reviews: 0,
                    lapses: 0,
                    frontSide: 0 // 0 = front, 1 = back (for reversed)
                };
                await this.add('cards', card);
                this.cards.push(card);
            }
            else if (type === 'basic-rev') {
                // Front card
                const card1 = {
                    id: noteId * 10,
                    noteId: noteId,
                    deckId: deckId,
                    type: 0,
                    due: 0,
                    interval: 0,
                    ease: 2.5,
                    reviews: 0,
                    lapses: 0,
                    frontSide: 0
                };
                
                // Back card (reversed)
                const card2 = {
                    id: noteId * 10 + 1,
                    noteId: noteId,
                    deckId: deckId,
                    type: 0,
                    due: 0,
                    interval: 0,
                    ease: 2.5,
                    reviews: 0,
                    lapses: 0,
                    frontSide: 1
                };
                
                await this.add('cards', card1);
                await this.add('cards', card2);
                this.cards.push(card1, card2);
            }
            else if (type === 'cloze') {
                // Extract cloze numbers
                const clozeRegex = /{{c(\d+)::(.*?)}}/g;
                const matches = [...front.matchAll(clozeRegex)];
                const clozeNumbers = [...new Set(matches.map(m => parseInt(m[1])))];
                
                // If no cloze found, create one card
                const clozeCount = clozeNumbers.length > 0 ? clozeNumbers.length : 1;
                
                for (let i = 0; i < clozeCount; i++) {
                    const card = {
                        id: noteId * 10 + i,
                        noteId: noteId,
                        deckId: deckId,
                        type: 0,
                        due: 0,
                        interval: 0,
                        ease: 2.5,
                        reviews: 0,
                        lapses: 0,
                        clozeNumber: i + 1
                    };
                    await this.add('cards', card);
                    this.cards.push(card);
                }
            }
            
            // Clear form
            document.getElementById('f-front').value = '';
            document.getElementById('f-back').value = '';
            
            alert('Card added successfully!');
            this.navigate('decks');
        }

        async startStudy(deckId) {
            this.currentDeck = deckId;
            const now = Date.now();
            const today = Math.floor(now / 86400000);
            
            // Get cards for this deck
            const deckCards = this.cards.filter(card => card.deckId === deckId);
            
            // Sort by priority: learning -> review -> new
            const learningCards = deckCards.filter(card => 
                (card.type === 1 || card.type === 3) && card.due < now / 1000
            ).sort((a, b) => a.due - b.due);
            
            const reviewCards = deckCards.filter(card => 
                card.type === 2 && card.due <= today
            ).sort((a, b) => a.due - b.due);
            
            const newCards = deckCards.filter(card => card.type === 0).slice(0, 20);
            
            this.studyQueue = [...learningCards, ...reviewCards, ...newCards];
            
            if (this.studyQueue.length === 0) {
                alert('No cards to study in this deck!');
                return;
            }
            
            // Update counts display
            document.getElementById('review-counts').innerHTML = `
                <span class="text-blue-400">${newCards.length}</span> 
                <span class="text-red-400">${learningCards.length}</span> 
                <span class="text-green-400">${reviewCards.length}</span>
            `;
            
            this.startTimer();
            this.navigate('review');
            this.nextCard();
        }

        startTimer() {
            this.startTime = Date.now();
            clearInterval(this.timerInterval);
            
            this.timerInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                document.getElementById('timer').textContent = `${elapsed}s`;
            }, 1000);
        }

        stopTimer() {
            clearInterval(this.timerInterval);
        }

        async nextCard() {
            if (this.studyQueue.length === 0) {
                this.stopTimer();
                alert('Study session complete!');
                this.navigate('decks');
                return;
            }
            
            this.currentCard = this.studyQueue[0];
            this.currentNote = this.notes.find(note => note.id === this.currentCard.noteId);
            this.isShowingBack = false;
            
            this.renderCardFront();
            document.getElementById('ans-controls').classList.add('hidden');
            document.getElementById('show-ans-control').classList.remove('hidden');
        }

        renderCardFront() {
            const content = document.getElementById('card-content');
            
            if (!this.currentNote) {
                content.innerHTML = '<div class="text-gray-500">Error loading card</div>';
                return;
            }
            
            let text = '';
            
            if (this.currentNote.type === 'cloze') {
                const clozeNum = this.currentCard.clozeNumber || 1;
                let frontText = this.currentNote.front;
                
                // Replace all clozes with their content
                const clozeRegex = /{{c\d+::(.*?)}}/g;
                frontText = frontText.replace(clozeRegex, '$1');
                
                // Now blank out the current cloze
                const currentClozeRegex = new RegExp(`{{c${clozeNum}::(.*?)}}`, 'g');
                text = this.currentNote.front.replace(currentClozeRegex, '<span class="cloze-blank">[...]</span>');
                
                // Replace other clozes with their content
                text = text.replace(/{{c\d+::(.*?)}}/g, '$1');
            }
            else if (this.currentCard.frontSide === 1) {
                // Reversed card: show back as front
                text = this.currentNote.back || 'No back content';
            }
            else {
                // Normal card: show front
                text = this.currentNote.front;
            }
            
            content.innerHTML = `<div class="card-content">${this.formatText(text)}</div>`;
        }

        showAnswer() {
            if (!this.currentNote) return;
            
            this.isShowingBack = true;
            const content = document.getElementById('card-content');
            
            let text = '';
            
            if (this.currentNote.type === 'cloze') {
                const clozeNum = this.currentCard.clozeNumber || 1;
                let frontText = this.currentNote.front;
                
                // Highlight the current cloze
                const currentClozeRegex = new RegExp(`{{c${clozeNum}::(.*?)}}`, 'g');
                frontText = frontText.replace(currentClozeRegex, '<span class="cloze">$1</span>');
                
                // Replace other clozes with their content
                frontText = frontText.replace(/{{c\d+::(.*?)}}/g, '$1');
                
                text = `<div class="mb-4">${this.formatText(frontText)}</div>`;
                
                if (this.currentNote.back) {
                    text += `<div class="mt-4 pt-4 border-t border-gray-600">${this.formatText(this.currentNote.back)}</div>`;
                }
            }
            else if (this.currentCard.frontSide === 1) {
                // Reversed card: front was back, answer is front
                text = `
                    <div class="mb-4">${this.formatText(this.currentNote.back || 'No back content')}</div>
                    <div class="mt-4 pt-4 border-t border-gray-600">${this.formatText(this.currentNote.front)}</div>
                `;
            }
            else {
                // Normal card
                text = `
                    <div class="mb-4">${this.formatText(this.currentNote.front)}</div>
                    <div class="mt-4 pt-4 border-t border-gray-600">${this.formatText(this.currentNote.back || 'No answer provided')}</div>
                `;
            }
            
            content.innerHTML = `<div class="card-content">${text}</div>`;
            
            // Show answer buttons
            document.getElementById('show-ans-control').classList.add('hidden');
            document.getElementById('ans-controls').classList.remove('hidden');
        }

        formatText(text) {
            if (!text) return '';
            
            return text
                .replace(/\n/g, '<br>')
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                .replace(/`(.*?)`/g, '<code class="bg-gray-800 px-1 rounded">$1</code>');
        }

        async answerCard(rating) {
            if (!this.currentCard) return;
            
            // Update card using SM-2 algorithm
            const updatedCard = this.sm2(this.currentCard, rating);
            
            // Remove from queue
            this.studyQueue.shift();
            
            // Update in database
            await this.put('cards', updatedCard);
            
            // Update in local array
            const index = this.cards.findIndex(c => c.id === updatedCard.id);
            if (index !== -1) {
                this.cards[index] = updatedCard;
            }
            
            // Next card
            this.nextCard();
        }

        sm2(card, rating) {
            // Simple SM-2 implementation
            const now = Date.now();
            const today = Math.floor(now / 86400000);
            
            let newInterval = 0;
            let newType = card.type;
            let newDue = 0;
            let newEase = card.ease;
            
            if (card.type === 0) { // New card
                if (rating >= 3) {
                    newType = 2; // Graduate to review
                    newInterval = 1; // 1 day
                    newDue = today + newInterval;
                } else {
                    newType = 1; // Still learning
                    newInterval = 1; // 1 minute in seconds
                    newDue = now / 1000 + newInterval;
                }
            } else if (card.type === 1 || card.type === 3) { // Learning or relearning
                if (rating >= 3) {
                    newType = 2;
                    newInterval = 1;
                    newDue = today + newInterval;
                } else {
                    newInterval = 1;
                    newDue = now / 1000 + newInterval;
                }
            } else if (card.type === 2) { // Review
                if (rating === 1) { // Again
                    newType = 3; // Relearning
                    newEase = Math.max(1.3, card.ease - 0.2);
                    newInterval = 1;
                    newDue = now / 1000 + newInterval;
                } else {
                    newEase = card.ease + (rating - 3) * 0.1;
                    newEase = Math.max(1.3, Math.min(newEase, 5.0));
                    
                    if (rating === 2) { // Hard
                        newInterval = Math.max(1, Math.floor(card.interval * 1.2));
                    } else if (rating === 3) { // Good
                        newInterval = Math.floor(card.interval * newEase);
                    } else if (rating === 4) { // Easy
                        newInterval = Math.floor(card.interval * newEase * 1.3);
                    }
                    
                    newDue = today + newInterval;
                }
            }
            
            return {
                ...card,
                type: newType,
                interval: newInterval,
                due: newDue,
                ease: newEase,
                reviews: card.reviews + 1,
                lapses: rating === 1 ? card.lapses + 1 : card.lapses,
                lastReviewed: now
            };
        }

        renderBrowser(query = '') {
            const container = document.getElementById('browser-list');
            container.innerHTML = '';
            
            const filteredNotes = this.notes.filter(note => {
                if (!query) return true;
                return note.front.toLowerCase().includes(query.toLowerCase()) ||
                       note.back.toLowerCase().includes(query.toLowerCase());
            }).slice(0, 50);
            
            filteredNotes.forEach(note => {
                const deck = this.decks.find(d => d.id === note.deckId);
                const noteCards = this.cards.filter(card => card.noteId === note.id);
                
                const element = document.createElement('div');
                element.className = 'p-4 border-b border-gray-800';
                element.innerHTML = `
                    <div class="font-semibold truncate">${this.formatText(note.front.substring(0, 100))}</div>
                    <div class="text-sm text-gray-500">${deck ? deck.name : 'Unknown deck'} â€¢ ${noteCards.length} card(s)</div>
                `;
                container.appendChild(element);
            });
        }

        renderStats() {
            const now = Date.now();
            const today = Math.floor(now / 86400000);
            
            const totalCards = this.cards.length;
            const dueToday = this.cards.filter(card => {
                if (card.type === 0) return true; // New cards
                if (card.type === 1 || card.type === 3) return card.due < now / 1000;
                if (card.type === 2) return card.due <= today;
                return false;
            }).length;
            
            const learning = this.cards.filter(card => 
                (card.type === 1 || card.type === 3) && card.due < now / 1000
            ).length;
            
            const toReview = this.cards.filter(card => 
                card.type === 2 && card.due <= today
            ).length;
            
            document.getElementById('stat-total').textContent = totalCards;
            document.getElementById('stat-due').textContent = dueToday;
            document.getElementById('stat-learn').textContent = learning;
            document.getElementById('stat-review').textContent = toReview;
        }
    }

    // Initialize app when page loads
    document.addEventListener('DOMContentLoaded', () => {
        window.app = new AnkiApp();
    });
    </script>
</body>
</html>