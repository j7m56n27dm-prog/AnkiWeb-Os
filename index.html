<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Anki iOS - Made by ¬©Ô∏èMuhammad Daler</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    
    <style>
        :root {
            --bg-primary: #000000;
            --bg-secondary: #1c1c1e;
            --text-primary: #ffffff;
            --text-secondary: #8e8e93;
            --accent: #0a84ff;
            --danger: #ff453a;
            --success: #32d74b;
            --warning: #ff9f0a;
            --card-bg: #2c2c2e;
            --separator: #38383a;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            height: 100vh;
            overflow: hidden;
            -webkit-tap-highlight-color: transparent;
        }

        /* View System */
        .view {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding-top: 60px;
            padding-bottom: 70px;
            overflow-y: auto;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .view.active {
            display: block;
            opacity: 1;
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 60px;
            background: rgba(28, 28, 30, 0.95);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--separator);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
            z-index: 1000;
        }

        /* Tab Bar */
        .tab-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 70px;
            background: rgba(28, 28, 30, 0.95);
            backdrop-filter: blur(20px);
            border-top: 1px solid var(--separator);
            display: flex;
            justify-content: space-around;
            align-items: center;
            z-index: 1000;
        }

        .tab-item {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            font-size: 10px;
            gap: 4px;
            height: 100%;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tab-item.active {
            color: var(--accent);
        }

        .tab-item i {
            font-size: 20px;
        }

        /* Deck List */
        .deck-list-container {
            padding: 16px;
        }

        .deck-item {
            background-color: var(--bg-secondary);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }

        .deck-item:hover {
            background-color: var(--card-bg);
            border-color: var(--separator);
        }

        .deck-info {
            flex: 1;
        }

        .deck-name {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .deck-stats {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .deck-counts {
            display: flex;
            gap: 12px;
        }

        .count {
            font-size: 14px;
            font-weight: 600;
            padding: 4px 8px;
            border-radius: 6px;
            min-width: 32px;
            text-align: center;
        }

        .count-new { background: rgba(10, 132, 255, 0.2); color: var(--accent); }
        .count-learn { background: rgba(255, 159, 10, 0.2); color: var(--warning); }
        .count-review { background: rgba(50, 215, 75, 0.2); color: var(--success); }

        /* Flashcard */
        .flashcard-container {
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .flashcard {
            background: var(--card-bg);
            border-radius: 16px;
            width: 100%;
            max-width: 600px;
            min-height: 300px;
            padding: 32px 24px;
            font-size: 20px;
            line-height: 1.5;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            cursor: pointer;
            user-select: none;
            overflow-wrap: break-word;
            word-break: break-word;
            position: relative;
        }

        .card-content {
            width: 100%;
        }

        /* Review Controls */
        .review-controls {
            position: fixed;
            bottom: 80px;
            left: 0;
            width: 100%;
            padding: 0 16px;
            display: flex;
            gap: 8px;
            z-index: 900;
        }

        .btn-answer {
            flex: 1;
            padding: 14px 0;
            border-radius: 10px;
            font-weight: 600;
            font-size: 14px;
            color: white;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-answer:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .btn-answer:active {
            transform: translateY(0);
        }

        .btn-again { background-color: var(--danger); }
        .btn-hard { background-color: var(--warning); }
        .btn-good { background-color: var(--success); }
        .btn-easy { background-color: var(--accent); }

        .btn-answer small {
            font-size: 10px;
            opacity: 0.9;
            font-weight: normal;
            margin-top: 2px;
        }

        /* Form Elements */
        .form-container {
            padding: 20px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            color: var(--text-secondary);
            font-size: 14px;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .form-input,
        .form-textarea,
        .form-select {
            width: 100%;
            padding: 14px;
            background: var(--bg-secondary);
            border: 2px solid var(--separator);
            border-radius: 10px;
            color: var(--text-primary);
            font-size: 16px;
            font-family: inherit;
            transition: all 0.2s ease;
        }

        .form-input:focus,
        .form-textarea:focus,
        .form-select:focus {
            outline: none;
            border-color: var(--accent);
        }

        .form-textarea {
            min-height: 120px;
            resize: vertical;
            line-height: 1.5;
        }

        .form-button {
            width: 100%;
            padding: 16px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .form-button:hover {
            background: #007AFF;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(10, 132, 255, 0.3);
        }

        .form-button:active {
            transform: translateY(0);
        }

        /* Cloze Styles */
        .cloze {
            color: var(--accent);
            font-weight: bold;
            background: rgba(10, 132, 255, 0.15);
            padding: 4px 6px;
            border-radius: 6px;
            border: 1px solid rgba(10, 132, 255, 0.3);
        }

        .cloze-blank {
            color: var(--accent);
            font-weight: bold;
            background: rgba(10, 132, 255, 0.1);
            padding: 4px 8px;
            border-radius: 6px;
            border: 2px dashed var(--accent);
            cursor: pointer;
            display: inline-block;
            min-width: 60px;
        }

        /* Browser */
        .browser-container {
            padding: 20px;
        }

        .browser-item {
            background: var(--bg-secondary);
            padding: 16px;
            margin-bottom: 12px;
            border-radius: 12px;
            border-left: 4px solid var(--accent);
            transition: all 0.2s ease;
        }

        .browser-item:hover {
            background: var(--card-bg);
            transform: translateX(4px);
        }

        /* Stats */
        .stats-container {
            padding: 20px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
            margin-bottom: 24px;
        }

        .stat-card {
            background: var(--card-bg);
            padding: 20px;
            border-radius: 16px;
            text-align: center;
            transition: all 0.2s ease;
        }

        .stat-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
        }

        .stat-value {
            font-size: 36px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .stat-label {
            font-size: 14px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        /* FAB */
        .fab {
            position: fixed;
            bottom: 90px;
            right: 20px;
            width: 60px;
            height: 60px;
            border-radius: 30px;
            background: var(--accent);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            box-shadow: 0 8px 24px rgba(10, 132, 255, 0.4);
            z-index: 900;
            cursor: pointer;
            border: none;
            transition: all 0.2s ease;
        }

        .fab:hover {
            transform: scale(1.1);
            box-shadow: 0 12px 32px rgba(10, 132, 255, 0.5);
        }

        .fab:active {
            transform: scale(0.95);
        }

        /* Cloze Examples */
        .cloze-examples {
            background: var(--bg-secondary);
            padding: 16px;
            margin: 20px 0;
            border-radius: 12px;
            border: 1px solid var(--separator);
        }

        .cloze-examples h4 {
            color: var(--accent);
            margin-bottom: 12px;
            font-size: 16px;
            font-weight: 600;
        }

        .cloze-examples code {
            background: rgba(255,255,255,0.1);
            padding: 4px 8px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            margin: 4px 0;
            display: inline-block;
        }

        .cloze-examples p {
            margin: 8px 0;
            color: var(--text-secondary);
            font-size: 14px;
        }

        /* Utility Classes */
        .hidden {
            display: none !important;
        }

        .text-center {
            text-align: center;
        }

        .mb-4 {
            margin-bottom: 16px;
        }

        .mt-4 {
            margin-top: 16px;
        }

        .p-4 {
            padding: 16px;
        }

        /* Loading States */
        .loading {
            opacity: 0.5;
            pointer-events: none;
        }

        /* Error States */
        .error-message {
            background: rgba(255, 69, 58, 0.1);
            color: var(--danger);
            padding: 12px 16px;
            border-radius: 8px;
            margin: 16px;
            text-align: center;
            border: 1px solid rgba(255, 69, 58, 0.3);
        }

        .success-message {
            background: rgba(50, 215, 75, 0.1);
            color: var(--success);
            padding: 12px 16px;
            border-radius: 8px;
            margin: 16px;
            text-align: center;
            border: 1px solid rgba(50, 215, 75, 0.3);
        }

        /* Card Actions */
        .card-actions {
            position: absolute;
            top: 16px;
            right: 16px;
            display: flex;
            gap: 8px;
        }

        .card-action-btn {
            width: 36px;
            height: 36px;
            border-radius: 18px;
            background: rgba(0,0,0,0.3);
            border: none;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .card-action-btn:hover {
            background: rgba(0,0,0,0.5);
            transform: scale(1.1);
        }

        /* Progress Bar */
        .progress-bar {
            height: 4px;
            background: var(--separator);
            border-radius: 2px;
            overflow: hidden;
            margin: 8px 16px;
        }

        .progress-fill {
            height: 100%;
            background: var(--accent);
            transition: width 0.3s ease;
        }

        /* Study Info */
        .study-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 16px;
            margin-bottom: 20px;
        }

        .study-counts {
            display: flex;
            gap: 16px;
        }

        .study-count {
            font-size: 14px;
            font-weight: 600;
        }

        .study-timer {
            font-size: 14px;
            color: var(--text-secondary);
            font-family: 'Courier New', monospace;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <h1 id="header-title" class="text-lg font-bold">Anki iOS</h1>
        <div id="header-actions"></div>
    </div>

    <!-- Progress Bar -->
    <div class="progress-bar">
        <div id="progress-fill" class="progress-fill" style="width: 0%"></div>
    </div>

    <!-- Views -->
    <div id="view-decks" class="view active">
        <div class="deck-list-container">
            <h2 class="text-xl font-bold mb-6">My Decks</h2>
            <div id="deck-list">
                <!-- Decks will be loaded here -->
            </div>
        </div>
        <button class="fab" id="add-deck-btn">
            <i class="fa-solid fa-plus"></i>
        </button>
    </div>

    <div id="view-review" class="view">
        <div class="study-info">
            <div class="study-counts">
                <span class="study-count text-blue-400" id="new-count">0</span>
                <span class="study-count text-red-400" id="learn-count">0</span>
                <span class="study-count text-green-400" id="review-count">0</span>
            </div>
            <div class="study-timer" id="timer">00:00</div>
        </div>

        <div class="flashcard-container">
            <div class="flashcard" id="card-content">
                <div class="card-content">
                    <div class="text-gray-500">Tap to start studying...</div>
                </div>
                <div class="card-actions">
                    <button class="card-action-btn" id="edit-card-btn" title="Edit">
                        <i class="fa-solid fa-pen"></i>
                    </button>
                    <button class="card-action-btn" id="delete-card-btn" title="Delete">
                        <i class="fa-solid fa-trash"></i>
                    </button>
                </div>
            </div>
        </div>

        <div id="answer-controls" class="review-controls hidden">
            <button class="btn-answer btn-again" data-rating="1">Again<br><small>1m</small></button>
            <button class="btn-answer btn-hard" data-rating="2">Hard<br><small>10m</small></button>
            <button class="btn-answer btn-good" data-rating="3">Good<br><small>1d</small></button>
            <button class="btn-answer btn-easy" data-rating="4">Easy<br><small>4d</small></button>
        </div>

        <div id="show-answer-control" class="review-controls">
            <button class="btn-answer" style="background: var(--card-bg);" id="show-answer-btn">
                Show Answer
            </button>
        </div>
    </div>

    <div id="view-add" class="view">
        <div class="form-container">
            <h2 class="text-xl font-bold mb-6">Add New Card</h2>

            <div class="form-group">
                <label class="form-label">Deck</label>
                <select class="form-select" id="deck-select">
                    <option value="">Loading decks...</option>
                </select>
            </div>

            <div class="form-group">
                <label class="form-label">Card Type</label>
                <select class="form-select" id="card-type">
                    <option value="basic">Basic</option>
                    <option value="basic-rev">Basic (and Reversed Card)</option>
                    <option value="cloze">Cloze</option>
                    <option value="cloze+">Cloze+ (Multiple deletions)</option>
                </select>
            </div>

            <div id="fields-container">
                <div class="form-group">
                    <label class="form-label" id="front-label">Front</label>
                    <textarea class="form-textarea" id="front-field" placeholder="Enter question or text..."></textarea>
                </div>

                <div class="form-group">
                    <label class="form-label" id="back-label">Back</label>
                    <textarea class="form-textarea" id="back-field" placeholder="Enter answer or additional information..."></textarea>
                </div>
            </div>

            <div class="cloze-examples hidden" id="cloze-examples">
                <h4>Cloze Syntax Examples:</h4>
                <p>‚Ä¢ <strong>Basic cloze:</strong> <code>{{c1::capital}} of France</code></p>
                <p>‚Ä¢ <strong>Multiple clozes:</strong> <code>{{c1::Paris}} is the {{c2::capital}} of {{c3::France}}</code></p>
                <p>‚Ä¢ <strong>Cloze with hint:</strong> <code>{{c1::Paris::capital city}}</code></p>
                <p>‚Ä¢ <strong>Nested cloze:</strong> <code>The {{c1::Eiffel Tower}} is in {{c2::Paris}}</code></p>
            </div>

            <button class="form-button" id="save-card-btn">
                <i class="fa-solid fa-plus mr-2"></i>Add Card
            </button>
        </div>
    </div>

    <div id="view-browse" class="view">
        <div class="browser-container">
            <div class="form-group">
                <input type="text" class="form-input" id="search-input" placeholder="Search cards...">
            </div>
            <div id="browser-content">
                <!-- Cards will be loaded here -->
            </div>
        </div>
    </div>

    <div id="view-stats" class="view">
        <div class="stats-container">
            <h2 class="text-xl font-bold mb-6">Statistics</h2>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value text-blue-500" id="stat-total">0</div>
                    <div class="stat-label">Total Cards</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value text-green-500" id="stat-due">0</div>
                    <div class="stat-label">Due Today</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value text-yellow-500" id="stat-learn">0</div>
                    <div class="stat-label">Learning</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value text-purple-500" id="stat-review">0</div>
                    <div class="stat-label">To Review</div>
                </div>
            </div>

            <div class="stat-card mt-4">
                <div class="stat-value text-accent" id="stat-studied">0</div>
                <div class="stat-label">Studied Today</div>
            </div>
        </div>
    </div>

    <!-- Tab Bar -->
    <div class="tab-bar">
        <div class="tab-item active" data-view="decks">
            <i class="fa-solid fa-layer-group"></i>
            <span>Decks</span>
        </div>
        <div class="tab-item" data-view="review">
            <i class="fa-solid fa-graduation-cap"></i>
            <span>Study</span>
        </div>
        <div class="tab-item" data-view="add">
            <i class="fa-solid fa-plus-circle"></i>
            <span>Add</span>
        </div>
        <div class="tab-item" data-view="browse">
            <i class="fa-solid fa-magnifying-glass"></i>
            <span>Browse</span>
        </div>
        <div class="tab-item" data-view="stats">
            <i class="fa-solid fa-chart-simple"></i>
            <span>Stats</span>
        </div>
    </div>

    <script>
    // Anki iOS - Made by ¬©Ô∏èMuhammad Daler
    class AnkiApp {
        constructor() {
            this.db = null;
            this.currentDeck = null;
            this.studyQueue = [];
            this.currentCard = null;
            this.currentNote = null;
            this.isShowingAnswer = false;
            this.studySession = {
                startTime: null,
                timer: null,
                cardsStudied: 0,
                totalCards: 0
            };
            
            this.init();
        }

        async init() {
            console.log("üöÄ Anki iOS Initializing...");
            try {
                await this.initDatabase();
                await this.loadDefaultData();
                this.setupEventListeners();
                this.setupNavigation();
                this.updateCardTypeUI();
                await this.updateDeckSelect();
                await this.renderDeckList();
                await this.updateStats();
                
                console.log("‚úÖ Anki iOS Initialized Successfully");
                
                // Check for first run
                const cards = await this.getAll('cards');
                if (cards.length === 0) {
                    this.showWelcomeMessage();
                }
                
            } catch (error) {
                console.error("‚ùå Initialization Error:", error);
                this.showError("Failed to initialize app. Please refresh the page.");
            }
        }

        async initDatabase() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('AnkiIOSDB', 4);
                
                request.onerror = () => {
                    console.error("Database error:", request.error);
                    reject(request.error);
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    console.log("Upgrading database to version", event.oldVersion, "‚Üí", event.newVersion);
                    
                    // Create decks store
                    if (!db.objectStoreNames.contains('decks')) {
                        console.log("Creating 'decks' store");
                        const deckStore = db.createObjectStore('decks', { keyPath: 'id' });
                        deckStore.createIndex('name', 'name', { unique: true });
                        deckStore.createIndex('created', 'created');
                    }
                    
                    // Create notes store
                    if (!db.objectStoreNames.contains('notes')) {
                        console.log("Creating 'notes' store");
                        const noteStore = db.createObjectStore('notes', { keyPath: 'id' });
                        noteStore.createIndex('deckId', 'deckId');
                        noteStore.createIndex('type', 'type');
                        noteStore.createIndex('created', 'created');
                    }
                    
                    // Create cards store
                    if (!db.objectStoreNames.contains('cards')) {
                        console.log("Creating 'cards' store");
                        const cardStore = db.createObjectStore('cards', { keyPath: 'id' });
                        cardStore.createIndex('deckId', 'deckId');
                        cardStore.createIndex('noteId', 'noteId');
                        cardStore.createIndex('due', 'due');
                        cardStore.createIndex('type', 'type');
                        cardStore.createIndex('clozeNumber', 'clozeNumber');
                        cardStore.createIndex('ord', 'ord');
                    }
                    
                    // Create revlog store
                    if (!db.objectStoreNames.contains('revlog')) {
                        console.log("Creating 'revlog' store");
                        const revlogStore = db.createObjectStore('revlog', { keyPath: 'id' });
                        revlogStore.createIndex('cardId', 'cardId');
                        revlogStore.createIndex('date', 'date');
                    }
                };
                
                request.onsuccess = (event) => {
                    this.db = event.target.result;
                    console.log("‚úÖ Database initialized successfully");
                    
                    // Handle database errors
                    this.db.onerror = (e) => {
                        console.error('Database error:', e.target.error);
                        this.showError('Database error occurred');
                    };
                    
                    resolve();
                };
            });
        }

        async loadDefaultData() {
            const decks = await this.getAll('decks');
            if (decks.length === 0) {
                console.log("Creating default deck...");
                const defaultDeck = {
                    id: 1,
                    name: 'Default',
                    created: Date.now(),
                    desc: 'Your default deck'
                };
                
                try {
                    await this.add('decks', defaultDeck);
                    console.log("‚úÖ Default deck created");
                    
                    // Add sample cards
                    await this.addSampleCards();
                    
                } catch (error) {
                    console.error("Error creating default deck:", error);
                }
            }
        }

        async addSampleCards() {
            console.log("Adding sample cards...");
            
            // Sample Basic Card
            const noteId1 = Date.now();
            await this.add('notes', {
                id: noteId1,
                deckId: 1,
                type: 'basic',
                front: 'What is the capital of France?',
                back: 'Paris',
                created: Date.now()
            });
            
            await this.add('cards', {
                id: noteId1 * 10,
                noteId: noteId1,
                deckId: 1,
                ord: 0,
                type: 0,
                interval: 0,
                ease: 2.5,
                due: 0,
                reviews: 0,
                lapses: 0,
                created: Date.now()
            });
            
            // Sample Cloze Card
            const noteId2 = DateNow() + 1;
            await this.add('notes', {
                id: noteId2,
                deckId: 1,
                type: 'cloze',
                front: 'The {{c1::capital}} of France is {{c2::Paris}}.',
                back: 'France is a country in Europe.',
                created: Date.now()
            });
            
            await this.add('cards', {
                id: noteId2 * 10,
                noteId: noteId2,
                deckId: 1,
                clozeNumber: 1,
                type: 0,
                interval: 0,
                ease: 2.5,
                due: 0,
                reviews: 0,
                lapses: 0,
                created: Date.now()
            });
            
            await this.add('cards', {
                id: noteId2 * 10 + 1,
                noteId: noteId2,
                deckId: 1,
                clozeNumber: 2,
                type: 0,
                interval: 0,
                ease: 2.5,
                due: 0,
                reviews: 0,
                lapses: 0,
                created: Date.now()
            });
            
            console.log("‚úÖ Sample cards added");
        }

        // Database Helper Methods
        async getAll(storeName) {
            return new Promise((resolve, reject) => {
                try {
                    const transaction = this.db.transaction([storeName], 'readonly');
                    const store = transaction.objectStore(storeName);
                    const request = store.getAll();
                    
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => reject(request.error);
                } catch (error) {
                    reject(error);
                }
            });
        }

        async get(storeName, key) {
            return new Promise((resolve, reject) => {
                try {
                    const transaction = this.db.transaction([storeName], 'readonly');
                    const store = transaction.objectStore(storeName);
                    const request = store.get(key);
                    
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                } catch (error) {
                    reject(error);
                }
            });
        }

        async add(storeName, data) {
            return new Promise((resolve, reject) => {
                try {
                    const transaction = this.db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.add(data);
                    
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                } catch (error) {
                    reject(error);
                }
            });
        }

        async put(storeName, data) {
            return new Promise((resolve, reject) => {
                try {
                    const transaction = this.db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.put(data);
                    
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                } catch (error) {
                    reject(error);
                }
            });
        }

        async delete(storeName, key) {
            return new Promise((resolve, reject) => {
                try {
                    const transaction = this.db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.delete(key);
                    
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                } catch (error) {
                    reject(error);
                }
            });
        }

        // Navigation
        setupNavigation() {
            // Tab navigation
            document.querySelectorAll('.tab-item').forEach(tab => {
                tab.addEventListener('click', (e) => {
                    const view = e.currentTarget.dataset.view;
                    this.switchView(view);
                });
            });

            // Update header title based on view
            const observer = new MutationObserver(() => {
                const activeView = document.querySelector('.view.active');
                if (activeView) {
                    const viewId = activeView.id.replace('view-', '');
                    const titles = {
                        'decks': 'My Decks',
                        'review': 'Study',
                        'add': 'Add Card',
                        'browse': 'Browse Cards',
                        'stats': 'Statistics'
                    };
                    document.getElementById('header-title').textContent = titles[viewId] || 'Anki iOS';
                }
            });

            observer.observe(document.body, { 
                childList: true, 
                subtree: true,
                attributes: true,
                attributeFilter: ['class']
            });
        }

        switchView(viewName) {
            // Hide all views
            document.querySelectorAll('.view').forEach(view => {
                view.classList.remove('active');
            });
            
            // Show selected view
            const targetView = document.getElementById(`view-${viewName}`);
            if (targetView) {
                targetView.classList.add('active');
            }
            
            // Update tabs
            document.querySelectorAll('.tab-item').forEach(tab => {
                tab.classList.remove('active');
                if (tab.dataset.view === viewName) {
                    tab.classList.add('active');
                }
            });
            
            // Perform view-specific actions
            switch(viewName) {
                case 'decks':
                    this.renderDeckList();
                    break;
                case 'browse':
                    this.renderBrowser();
                    break;
                case 'stats':
                    this.updateStats();
                    break;
                case 'review':
                    // Don't auto-start study session
                    break;
            }
        }

        // Deck Management
        async renderDeckList() {
            const container = document.getElementById('deck-list');
            if (!container) return;
            
            container.innerHTML = '<div class="text-gray-500 text-center p-8">Loading decks...</div>';
            
            try {
                const decks = await this.getAll('decks');
                const cards = await this.getAll('cards');
                
                if (decks.length === 0) {
                    container.innerHTML = `
                        <div class="error-message">
                            <p>No decks found. Create your first deck!</p>
                            <button class="form-button mt-4" onclick="ankiApp.createNewDeck()">
                                Create Deck
                            </button>
                        </div>
                    `;
                    return;
                }
                
                const now = Date.now();
                const today = Math.floor(now / 86400000); // Days since epoch
                
                container.innerHTML = '';
                
                for (const deck of decks) {
                    const deckCards = cards.filter(card => card.deckId === deck.id);
                    
                    // Calculate counts
                    const newCards = deckCards.filter(c => c.type === 0).length;
                    const learningCards = deckCards.filter(c => 
                        (c.type === 1 || c.type === 3) && c.due < now / 1000
                    ).length;
                    const reviewCards = deckCards.filter(c => 
                        c.type === 2 && c.due <= today
                    ).length;
                    
                    const deckElement = document.createElement('div');
                    deckElement.className = 'deck-item';
                    deckElement.innerHTML = `
                        <div class="deck-info">
                            <div class="deck-name">${this.escapeHtml(deck.name)}</div>
                            <div class="deck-stats">${deckCards.length} cards</div>
                        </div>
                        <div class="deck-counts">
                            ${newCards > 0 ? `<div class="count count-new">${newCards}</div>` : ''}
                            ${learningCards > 0 ? `<div class="count count-learn">${learningCards}</div>` : ''}
                            ${reviewCards > 0 ? `<div class="count count-review">${reviewCards}</div>` : ''}
                        </div>
                    `;
                    
                    deckElement.addEventListener('click', () => this.startStudySession(deck.id));
                    container.appendChild(deckElement);
                }
                
            } catch (error) {
                console.error('Error rendering deck list:', error);
                container.innerHTML = '<div class="error-message">Error loading decks</div>';
            }
        }

        async createNewDeck() {
            const name = prompt('Enter deck name:');
            if (!name || !name.trim()) {
                return;
            }
            
            try {
                // Check if deck with same name exists
                const decks = await this.getAll('decks');
                const exists = decks.some(d => d.name.toLowerCase() === name.toLowerCase());
                if (exists) {
                    this.showError('A deck with this name already exists');
                    return;
                }
                
                const deck = {
                    id: Date.now(),
                    name: name.trim(),
                    created: Date.now(),
                    desc: ''
                };
                
                await this.add('decks', deck);
                this.showSuccess('Deck created successfully!');
                
                // Update UI
                await this.renderDeckList();
                await this.updateDeckSelect();
                await this.updateStats();
                
            } catch (error) {
                console.error('Error creating deck:', error);
                this.showError('Failed to create deck');
            }
        }

        async updateDeckSelect() {
            const select = document.getElementById('deck-select');
            if (!select) return;
            
            try {
                const decks = await this.getAll('decks');
                select.innerHTML = '';
                
                if (decks.length === 0) {
                    select.innerHTML = '<option value="">No decks available</option>';
                    return;
                }
                
                decks.forEach(deck => {
                    const option = document.createElement('option');
                    option.value = deck.id;
                    option.textContent = deck.name;
                    select.appendChild(option);
                });
                
                // Select first deck by default
                if (decks.length > 0) {
                    select.value = decks[0].id;
                }
                
            } catch (error) {
                console.error('Error loading decks:', error);
                select.innerHTML = '<option value="">Error loading decks</option>';
            }
        }

        // Study Session
        async startStudySession(deckId) {
            console.log("Starting study session for deck:", deckId);
            
            try {
                this.currentDeck = deckId;
                const deck = await this.get('decks', deckId);
                if (!deck) {
                    this.showError('Deck not found');
                    return;
                }
                
                // Build study queue
                await this.buildStudyQueue(deckId);
                
                if (this.studyQueue.length === 0) {
                    this.showMessage('No cards to study right now!', 'info');
                    return;
                }
                
                // Update counts display
                const now = Date.now();
                const today = Math.floor(now / 86400000);
                const deckCards = (await this.getAll('cards')).filter(c => c.deckId === deckId);
                
                const newCount = deckCards.filter(c => c.type === 0).length;
                const learnCount = deckCards.filter(c => 
                    (c.type === 1 || c.type === 3) && c.due < now / 1000
                ).length;
                const reviewCount = deckCards.filter(c => c.type === 2 && c.due <= today).length;
                
                document.getElementById('new-count').textContent = newCount;
                document.getElementById('learn-count').textContent = learnCount;
                document.getElementById('review-count').textContent = reviewCount;
                
                // Start session
                this.studySession.startTime = Date.now();
                this.studySession.cardsStudied = 0;
                this.studySession.totalCards = this.studyQueue.length;
                
                this.startTimer();
                this.switchView('review');
                await this.showNextCard();
                
                // Update progress bar
                this.updateProgressBar();
                
            } catch (error) {
                console.error('Error starting study session:', error);
                this.showError('Failed to start study session');
            }
        }

        async buildStudyQueue(deckId) {
            try {
                const cards = await this.getAll('cards');
                const deckCards = cards.filter(card => card.deckId === deckId);
                
                if (deckCards.length === 0) {
                    this.studyQueue = [];
                    return;
                }
                
                const now = Date.now();
                const today = Math.floor(now / 86400000);
                
                // Sort cards by priority: learning -> review -> new
                const learningCards = deckCards.filter(card => 
                    (card.type === 1 || card.type === 3) && card.due < now / 1000
                ).sort((a, b) => a.due - b.due);
                
                const reviewCards = deckCards.filter(card => 
                    card.type === 2 && card.due <= today
                ).sort((a, b) => a.due - b.due);
                
                const newCards = deckCards.filter(card => card.type === 0);
                
                // Shuffle new cards for variety
                this.shuffleArray(newCards);
                
                this.studyQueue = [...learningCards, ...reviewCards, ...newCards.slice(0, 20)];
                
                console.log(`Study queue built: ${this.studyQueue.length} cards`);
                
            } catch (error) {
                console.error('Error building study queue:', error);
                this.studyQueue = [];
            }
        }

        async showNextCard() {
            if (this.studyQueue.length === 0) {
                await this.endStudySession();
                return;
            }
            
            this.currentCard = this.studyQueue.shift();
            this.currentNote = await this.get('notes', this.currentCard.noteId);
            this.isShowingAnswer = false;
            
            if (!this.currentNote) {
                console.error('Note not found for card:', this.currentCard);
                await this.showNextCard();
                return;
            }
            
            this.renderCardFront();
            
            // Update controls
            document.getElementById('show-answer-control').classList.remove('hidden');
            document.getElementById('answer-controls').classList.add('hidden');
            
            // Update progress
            this.studySession.cardsStudied++;
            this.updateProgressBar();
        }

        renderCardFront() {
            const container = document.getElementById('card-content');
            if (!container) return;
            
            if (!this.currentNote) {
                container.innerHTML = '<div class="error-message">Error loading card</div>';
                return;
            }
            
            let content = '';
            
            switch(this.currentNote.type) {
                case 'cloze':
                case 'cloze+':
                    content = this.renderClozeFront();
                    break;
                    
                case 'basic-rev':
                    if (this.currentCard.ord === 1) {
                        // Reversed card: show back as front
                        content = this.formatText(this.currentNote.back || 'No content');
                    } else {
                        // Normal card: show front
                        content = this.formatText(this.currentNote.front);
                    }
                    break;
                    
                default:
                    content = this.formatText(this.currentNote.front);
            }
            
            container.innerHTML = `
                <div class="card-content">
                    ${content}
                </div>
                <div class="card-actions">
                    <button class="card-action-btn" onclick="ankiApp.editCurrentCard()" title="Edit">
                        <i class="fa-solid fa-pen"></i>
                    </button>
                    <button class="card-action-btn" onclick="ankiApp.deleteCurrentCard()" title="Delete">
                        <i class="fa-solid fa-trash"></i>
                    </button>
                </div>
            `;
        }

        renderClozeFront() {
            let text = this.currentNote.front;
            const clozeNumber = this.currentCard.clozeNumber || 1;
            
            // Replace the current cloze with blank
            const currentClozeRegex = new RegExp(`{{c${clozeNumber}::(.*?)}}`, 'g');
            text = text.replace(currentClozeRegex, (match, content) => {
                // Check if there's a hint
                const parts = content.split('::');
                if (parts.length > 1) {
                    return `<span class="cloze-blank" title="${this.escapeHtml(parts[1])}">[...]</span>`;
                }
                return '<span class="cloze-blank">[...]</span>';
            });
            
            // Replace other clozes with their content
            text = text.replace(/{{c\d+::(.*?)}}/g, (match, content) => {
                const parts = content.split('::');
                return this.escapeHtml(parts[0]);
            });
            
            return this.formatText(text);
        }

        showAnswer() {
            if (!this.currentNote || this.isShowingAnswer) return;
            
            this.isShowingAnswer = true;
            const container = document.getElementById('card-content');
            
            let content = '';
            
            switch(this.currentNote.type) {
                case 'cloze':
                case 'cloze+':
                    content = this.renderClozeAnswer();
                    break;
                    
                case 'basic-rev':
                    if (this.currentCard.ord === 1) {
                        content = `
                            <div class="mb-8 text-xl">${this.formatText(this.currentNote.back || 'No content')}</div>
                            <div class="border-t border-gray-600 pt-6 mt-6">
                                <div class="text-sm text-gray-500 mb-2">Answer:</div>
                                <div class="text-lg">${this.formatText(this.currentNote.front)}</div>
                            </div>
                        `;
                    } else {
                        content = `
                            <div class="mb-8 text-xl">${this.formatText(this.currentNote.front)}</div>
                            <div class="border-t border-gray-600 pt-6 mt-6">
                                <div class="text-sm text-gray-500 mb-2">Answer:</div>
                                <div class="text-lg">${this.formatText(this.currentNote.back || 'No answer')}</div>
                            </div>
                        `;
                    }
                    break;
                    
                default:
                    content = `
                        <div class="mb-8 text-xl">${this.formatText(this.currentNote.front)}</div>
                        <div class="border-t border-gray-600 pt-6 mt-6">
                            <div class="text-sm text-gray-500 mb-2">Answer:</div>
                            <div class="text-lg">${this.formatText(this.currentNote.back || 'No answer')}</div>
                        </div>
                    `;
            }
            
            container.innerHTML = `
                <div class="card-content">
                    ${content}
                </div>
                <div class="card-actions">
                    <button class="card-action-btn" onclick="ankiApp.editCurrentCard()" title="Edit">
                        <i class="fa-solid fa-pen"></i>
                    </button>
                    <button class="card-action-btn" onclick="ankiApp.deleteCurrentCard()" title="Delete">
                        <i class="fa-solid fa-trash"></i>
                    </button>
                </div>
            `;
            
            // Show rating buttons
            document.getElementById('show-answer-control').classList.add('hidden');
            document.getElementById('answer-controls').classList.remove('hidden');
            
            // Update button times based on SM-2 prediction
            this.updateAnswerButtonTimes();
        }

        renderClozeAnswer() {
            let text = this.currentNote.front;
            const clozeNumber = this.currentCard.clozeNumber || 1;
            
            // Highlight the current cloze
            const currentClozeRegex = new RegExp(`{{c${clozeNumber}::(.*?)}}`, 'g');
            text = text.replace(currentClozeRegex, (match, content) => {
                const parts = content.split('::');
                return `<span class="cloze">${this.escapeHtml(parts[0])}</span>`;
            });
            
            // Replace other clozes with their content
            text = text.replace(/{{c\d+::(.*?)}}/g, (match, content) => {
                const parts = content.split('::');
                return this.escapeHtml(parts[0]);
            });
            
            let content = `<div class="mb-8 text-xl">${this.formatText(text)}</div>`;
            
            // Add back content if exists
            if (this.currentNote.back && this.currentNote.back.trim()) {
                content += `
                    <div class="border-t border-gray-600 pt-6 mt-6">
                        <div class="text-sm text-gray-500 mb-2">Additional Info:</div>
                        <div>${this.formatText(this.currentNote.back)}</div>
                    </div>
                `;
            }
            
            return content;
        }

        async answerCard(rating) {
            try {
                if (!this.currentCard) return;
                
                console.log(`Answering card ${this.currentCard.id} with rating ${rating}`);
                
                // Update card using SM-2 algorithm
                const updatedCard = this.applySM2(this.currentCard, rating);
                
                // Save updated card
                await this.put('cards', updatedCard);
                
                // Log review
                const reviewTime = Math.floor((Date.now() - this.studySession.startTime) / 1000);
                await this.add('revlog', {
                    id: Date.now(),
                    cardId: this.currentCard.id,
                    rating: rating,
                    time: reviewTime,
                    date: Date.now(),
                    ease: updatedCard.ease,
                    interval: updatedCard.interval
                });
                
                // Reset timer for next card
                this.studySession.startTime = Date.now();
                
                // Show next card
                await this.showNextCard();
                
            } catch (error) {
                console.error('Error answering card:', error);
                this.showError('Failed to save answer');
            }
        }

        applySM2(card, rating) {
            const now = Date.now();
            const today = Math.floor(now / 86400000);
            
            let newType = card.type;
            let newInterval = card.interval || 0;
            let newDue = card.due || 0;
            let newEase = card.ease || 2.5;
            let newReviews = (card.reviews || 0) + 1;
            let newLapses = card.lapses || 0;
            
            console.log(`Applying SM2: card type=${card.type}, rating=${rating}, current interval=${newInterval}`);
            
            // SM-2 Algorithm
            if (card.type === 0) { // New card
                if (rating >= 3) {
                    newType = 2; // Graduate to review
                    newInterval = 1; // 1 day
                    newDue = today + newInterval;
                    console.log(`New card graduated to review, interval=${newInterval}`);
                } else {
                    newType = 1; // Still learning
                    newInterval = 1; // 1 minute in days
                    newDue = Math.floor(now / 1000) + (newInterval * 60); // Convert to seconds
                    console.log(`New card stays learning, due in ${newInterval} min`);
                }
            } 
            else if (card.type === 1 || card.type === 3) { // Learning or Relearning
                if (rating >= 3) {
                    newType = 2; // Graduate to review
                    newInterval = 1; // 1 day
                    newDue = today + newInterval;
                    console.log(`Learning card graduated, interval=${newInterval}`);
                } else {
                    newInterval = 1; // 1 minute
                    newDue = Math.floor(now / 1000) + (newInterval * 60);
                    console.log(`Learning card continues, due in ${newInterval} min`);
                }
            } 
            else if (card.type === 2) { // Review
                if (rating === 1) { // Again
                    newType = 3; // Relearning
                    newEase = Math.max(1.3, newEase - 0.2);
                    newLapses++;
                    newInterval = 1; // 1 minute
                    newDue = Math.floor(now / 1000) + (newInterval * 60);
                    console.log(`Review card failed, relearning, new ease=${newEase}`);
                } else {
                    // Adjust ease factor
                    if (rating === 2) { // Hard
                        newEase = Math.max(1.3, newEase - 0.15);
                        newInterval = Math.max(1, Math.floor(newInterval * 1.2));
                    } else if (rating === 3) { // Good
                        newInterval = Math.floor(newInterval * newEase);
                    } else if (rating === 4) { // Easy
                        newEase = Math.min(5.0, newEase + 0.15);
                        newInterval = Math.floor(newInterval * newEase * 1.3);
                    }
                    
                    newDue = today + newInterval;
                    console.log(`Review card passed, new interval=${newInterval}, new ease=${newEase}`);
                }
            }
            
            return {
                ...card,
                type: newType,
                interval: newInterval,
                due: newDue,
                ease: newEase,
                reviews: newReviews,
                lapses: newLapses,
                lastReviewed: now
            };
        }

        updateAnswerButtonTimes() {
            if (!this.currentCard) return;
            
            // Predict intervals for each rating
            const ratings = [1, 2, 3, 4];
            ratings.forEach(rating => {
                const predicted = this.applySM2(this.currentCard, rating);
                const timeText = this.formatInterval(predicted.interval);
                const button = document.querySelector(`.btn-answer[data-rating="${rating}"] small`);
                if (button) {
                    button.textContent = timeText;
                }
            });
        }

        formatInterval(interval) {
            if (interval < 1) {
                return '1m';
            } else if (interval === 1) {
                return '1d';
            } else if (interval < 7) {
                return `${interval}d`;
            } else if (interval < 30) {
                const weeks = Math.floor(interval / 7);
                return `${weeks}w`;
            } else if (interval < 365) {
                const months = Math.floor(interval / 30);
                return `${months}mo`;
            } else {
                const years = Math.floor(interval / 365);
                return `${years}y`;
            }
        }

        // Card Creation
        updateCardTypeUI() {
            const cardType = document.getElementById('card-type');
            const clozeExamples = document.getElementById('cloze-examples');
            const frontLabel = document.getElementById('front-label');
            const backLabel = document.getElementById('back-label');
            
            if (!cardType) return;
            
            const updateUI = () => {
                const type = cardType.value;
                
                if (type === 'cloze' || type === 'cloze+') {
                    clozeExamples.classList.remove('hidden');
                    frontLabel.textContent = 'Text (use {{c1::cloze}} syntax)';
                    backLabel.textContent = 'Extra Information (optional)';
                    document.getElementById('front-field').placeholder = 'Example: The {{c1::capital}} of France is {{c2::Paris}}.';
                } else {
                    clozeExamples.classList.add('hidden');
                    frontLabel.textContent = 'Front';
                    backLabel.textContent = 'Back';
                    document.getElementById('front-field').placeholder = 'Enter question or text...';
                }
            };
            
            cardType.addEventListener('change', updateUI);
            updateUI(); // Initial update
        }

        async saveCard() {
            try {
                const deckId = document.getElementById('deck-select').value;
                const cardType = document.getElementById('card-type').value;
                const front = document.getElementById('front-field').value.trim();
                const back = document.getElementById('back-field').value.trim();
                
                // Validation
                if (!deckId) {
                    this.showError('Please select a deck');
                    return;
                }
                
                if (!front) {
                    this.showError('Front field cannot be empty');
                    return;
                }
                
                if ((cardType === 'basic' || cardType === 'basic-rev') && !back) {
                    this.showError('Back field cannot be empty for basic cards');
                    return;
                }
                
                // Create note
                const noteId = Date.now();
                const note = {
                    id: noteId,
                    deckId: parseInt(deckId),
                    type: cardType,
                    front: front,
                    back: back,
                    created: Date.now()
                };
                
                await this.add('notes', note);
                console.log(`Note created: ${noteId}`);
                
                // Create cards based on type
                if (cardType === 'basic') {
                    await this.createBasicCard(noteId, deckId, 0);
                } 
                else if (cardType === 'basic-rev') {
                    // Front card
                    await this.createBasicCard(noteId, deckId, 0);
                    // Back card (reversed)
                    await this.createBasicCard(noteId, deckId, 1);
                }
                else if (cardType === 'cloze' || cardType === 'cloze+') {
                    await this.createClozeCards(noteId, deckId, front);
                }
                
                // Clear form
                document.getElementById('front-field').value = '';
                document.getElementById('back-field').value = '';
                
                this.showSuccess('Card added successfully!');
                
                // Update stats and deck list
                await this.updateStats();
                await this.renderDeckList();
                
            } catch (error) {
                console.error('Error saving card:', error);
                this.showError('Failed to save card: ' + error.message);
            }
        }

        async createBasicCard(noteId, deckId, ord) {
            const cardId = Date.now() + ord;
            const card = {
                id: cardId,
                noteId: noteId,
                deckId: parseInt(deckId),
                ord: ord,
                type: 0, // New
                interval: 0,
                ease: 2.5,
                due: 0,
                reviews: 0,
                lapses: 0,
                created: Date.now()
            };
            
            await this.add('cards', card);
            console.log(`Basic card created: ${cardId}, ord: ${ord}`);
        }

        async createClozeCards(noteId, deckId, text) {
            // Extract all cloze numbers from text
            const clozeRegex = /{{c(\d+)::(.*?)}}/g;
            const matches = [...text.matchAll(clozeRegex)];
            const clozeNumbers = [...new Set(matches.map(m => parseInt(m[1])))];
            
            // If no cloze found, create one card
            if (clozeNumbers.length === 0) {
                console.log('No cloze syntax found, creating one card');
                clozeNumbers.push(1);
            }
            
            console.log(`Creating ${clozeNumbers.length} cloze cards for note ${noteId}`);
            
            // Create a card for each cloze
            for (let i = 0; i < clozeNumbers.length; i++) {
                const cardId = Date.now() + i;
                const card = {
                    id: cardId,
                    noteId: noteId,
                    deckId: parseInt(deckId),
                    clozeNumber: clozeNumbers[i],
                    type: 0, // New
                    interval: 0,
                    ease: 2.5,
                    due: 0,
                    reviews: 0,
                    lapses: 0,
                    created: Date.now()
                };
                
                await this.add('cards', card);
                console.log(`Cloze card created: ${cardId}, cloze: ${clozeNumbers[i]}`);
            }
        }

        // Browser
        async renderBrowser(query = '') {
            const container = document.getElementById('browser-content');
            if (!container) return;
            
            container.innerHTML = '<div class="text-gray-500 text-center p-8">Loading cards...</div>';
            
            try {
                const notes = await this.getAll('notes');
                const decks = await this.getAll('decks');
                const cards = await this.getAll('cards');
                
                let filteredNotes = notes;
                if (query) {
                    const searchTerm = query.toLowerCase();
                    filteredNotes = notes.filter(note => 
                        note.front.toLowerCase().includes(searchTerm) ||
                        note.back.toLowerCase().includes(searchTerm)
                    );
                }
                
                if (filteredNotes.length === 0) {
                    container.innerHTML = '<div class="error-message">No cards found</div>';
                    return;
                }
                
                container.innerHTML = '';
                
                for (const note of filteredNotes.slice(0, 100)) {
                    const deck = decks.find(d => d.id === note.deckId);
                    const noteCards = cards.filter(c => c.noteId === note.id);
                    
                    const noteElement = document.createElement('div');
                    noteElement.className = 'browser-item';
                    noteElement.innerHTML = `
                        <div class="font-semibold text-lg mb-2">${this.formatText(note.front.substring(0, 200))}</div>
                        <div class="text-gray-500 text-sm mb-2">${this.formatText(note.back.substring(0, 100))}</div>
                        <div class="flex justify-between items-center text-xs text-gray-400">
                            <span>${deck ? deck.name : 'Unknown'} ‚Ä¢ ${note.type}</span>
                            <span>${noteCards.length} card(s)</span>
                        </div>
                    `;
                    
                    container.appendChild(noteElement);
                }
                
            } catch (error) {
                console.error('Error rendering browser:', error);
                container.innerHTML = '<div class="error-message">Error loading cards</div>';
            }
        }

        // Statistics
        async updateStats() {
            try {
                const cards = await this.getAll('cards');
                const notes = await this.getAll('notes');
                const revlogs = await this.getAll('revlog');
                
                const now = Date.now();
                const today = Math.floor(now / 86400000);
                const todayStart = new Date();
                todayStart.setHours(0, 0, 0, 0);
                
                // Calculate stats
                const totalCards = cards.length;
                
                const dueToday = cards.filter(card => {
                    if (card.type === 0) return true; // New cards
                    if (card.type === 1 || card.type === 3) return card.due < now / 1000;
                    if (card.type === 2) return card.due <= today;
                    return false;
                }).length;
                
                const learningCards = cards.filter(card => 
                    (card.type === 1 || card.type === 3) && card.due < now / 1000
                ).length;
                
                const reviewCards = cards.filter(card => 
                    card.type === 2 && card.due <= today
                ).length;
                
                const studiedToday = revlogs.filter(log => 
                    new Date(log.date) >= todayStart
                ).length;
                
                // Update UI
                document.getElementById('stat-total').textContent = totalCards;
                document.getElementById('stat-due').textContent = dueToday;
                document.getElementById('stat-learn').textContent = learningCards;
                document.getElementById('stat-review').textContent = reviewCards;
                document.getElementById('stat-studied').textContent = studiedToday;
                
            } catch (error) {
                console.error('Error updating stats:', error);
            }
        }

        // Utility Methods
        formatText(text) {
            if (!text) return '';
            
            return text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/\n/g, '<br>')
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                .replace(/`(.*?)`/g, '<code class="bg-gray-800 px-2 py-1 rounded">$1</code>');
        }

        escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        startTimer() {
            this.stopTimer();
            this.studySession.timer = setInterval(() => {
                const elapsed = Math.floor((Date.now() - this.studySession.startTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                document.getElementById('timer').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }, 1000);
        }

        stopTimer() {
            if (this.studySession.timer) {
                clearInterval(this.studySession.timer);
                this.studySession.timer = null;
            }
        }

        updateProgressBar() {
            if (this.studySession.totalCards === 0) return;
            const progress = (this.studySession.cardsStudied / this.studySession.totalCards) * 100;
            document.getElementById('progress-fill').style.width = `${progress}%`;
        }

        async endStudySession() {
            this.stopTimer();
            
            const elapsed = Math.floor((Date.now() - this.studySession.startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            
            let message = `Study session complete!\n\n`;
            message += `Cards studied: ${this.studySession.cardsStudied}\n`;
            message += `Time spent: ${minutes} minute${minutes !== 1 ? 's' : ''}\n`;
            message += `Well done! üéâ`;
            
            alert(message);
            
            // Update stats and return to decks
            await this.updateStats();
            this.switchView('decks');
        }

        async editCurrentCard() {
            if (!this.currentCard || !this.currentNote) {
                this.showError('No card selected');
                return;
            }
            
            this.showMessage('Edit functionality coming soon!', 'info');
            // Note: In a full implementation, you would switch to edit view with pre-filled data
        }

        async deleteCurrentCard() {
            if (!this.currentCard || !this.currentNote) {
                this.showError('No card selected');
                return;
            }
            
            if (!confirm('Are you sure you want to delete this card?')) {
                return;
            }
            
            try {
                // Delete the card
                await this.delete('cards', this.currentCard.id);
                
                // Check if there are other cards for this note
                const cards = await this.getAll('cards');
                const noteCards = cards.filter(c => c.noteId === this.currentNote.id);
                
                // If this was the last card, delete the note too
                if (noteCards.length === 0) {
                    await this.delete('notes', this.currentNote.id);
                }
                
                // Remove from study queue
                this.studyQueue = this.studyQueue.filter(c => c.id !== this.currentCard.id);
                
                this.showSuccess('Card deleted successfully');
                
                // Show next card or end session
                if (this.studyQueue.length > 0) {
                    await this.showNextCard();
                } else {
                    await this.endStudySession();
                }
                
                // Update stats and deck list
                await this.updateStats();
                await this.renderDeckList();
                
            } catch (error) {
                console.error('Error deleting card:', error);
                this.showError('Failed to delete card');
            }
        }

        showError(message) {
            alert(`‚ùå ${message}`);
        }

        showSuccess(message) {
            alert(`‚úÖ ${message}`);
        }

        showMessage(message, type = 'info') {
            const icon = type === 'info' ? '‚ÑπÔ∏è' : type === 'success' ? '‚úÖ' : '‚ùå';
            alert(`${icon} ${message}`);
        }

        showWelcomeMessage() {
            setTimeout(() => {
                const welcomeMessage = `
Welcome to Anki iOS! üéâ

Here's what you can do:
1. Browse your default deck with sample cards
2. Create new decks using the + button
3. Add cards with different types (Basic, Cloze, etc.)
4. Study using spaced repetition (SM-2 algorithm)
5. Track your progress in Statistics

Enjoy learning! üìö
                `.trim();
                
                if (confirm(welcomeMessage + '\n\nWould you like to see the sample cards?')) {
                    this.switchView('decks');
                }
            }, 1000);
        }

        shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Event Listeners Setup
        setupEventListeners() {
            // Add deck button
            document.getElementById('add-deck-btn')?.addEventListener('click', () => {
                this.createNewDeck();
            });
            
            // Save card button
            document.getElementById('save-card-btn')?.addEventListener('click', () => {
                this.saveCard();
            });
            
            // Show answer button
            document.getElementById('show-answer-btn')?.addEventListener('click', () => {
                this.showAnswer();
            });
            
            // Card flip on click
            document.getElementById('card-content')?.addEventListener('click', (e) => {
                if (!e.target.closest('.card-action-btn') && !this.isShowingAnswer) {
                    this.showAnswer();
                }
            });
            
            // Answer buttons
            document.querySelectorAll('.btn-answer').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const rating = parseInt(e.currentTarget.dataset.rating);
                    this.answerCard(rating);
                });
            });
            
            // Search input
            document.getElementById('search-input')?.addEventListener('input', (e) => {
                this.renderBrowser(e.target.value);
            });
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                // Don't trigger shortcuts when typing in inputs/textarea
                if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT') {
                    return;
                }
                
                if (!this.isShowingAnswer && e.code === 'Space') {
                    this.showAnswer();
                    e.preventDefault();
                } else if (this.isShowingAnswer) {
                    switch(e.code) {
                        case 'Digit1':
                        case 'Numpad1':
                            this.answerCard(1);
                            e.preventDefault();
                            break;
                        case 'Digit2':
                        case 'Numpad2':
                            this.answerCard(2);
                            e.preventDefault();
                            break;
                        case 'Digit3':
                        case 'Numpad3':
                            this.answerCard(3);
                            e.preventDefault();
                            break;
                        case 'Digit4':
                        case 'Numpad4':
                            this.answerCard(4);
                            e.preventDefault();
                            break;
                    }
                }
            });
            
            // Handle beforeunload
            window.addEventListener('beforeunload', () => {
                this.stopTimer();
            });
        }
    }

    // Initialize app when page loads
    document.addEventListener('DOMContentLoaded', () => {
        console.log("üì± Anki iOS Loading...");
        window.ankiApp = new AnkiApp();
        
        // Add loading indicator
        document.body.classList.add('loading');
        setTimeout(() => {
            document.body.classList.remove('loading');
        }, 1000);
    });

    // Helper function for Date.now with fallback
    function DateNow() {
        return Date.now();
    }
    </script>
</body>
</html>